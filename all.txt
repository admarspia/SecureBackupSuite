src/main/java/packages/notification/NotificationService.java
src/main/java/packages/notification/NotificationController.java
src/main/java/packages/notification/Notification.java
src/main/java/packages/user/UserUI.java
package user;

import java.util.Scanner;
import java.util.Map;
import java.util.HashMap;
import java.io.*;
import java.sql.SQLException;

import exception.userservice.*;
import utils.manifest.ManifestDisplay;
import recovery.SelectiveRecoveryService;

public class UserUI {
    private static Scanner input = new Scanner(System.in);
    private static Map<String, String> selected = new HashMap<>();

    public static String receiveUsername() throws SQLException {
        while (true) {
            try {

                System.out.print("Enter username: ");
                String username = input.nextLine();
                System.out.println("After taking input");
                UserController.validateUsername(username);
                return username;
            } catch (InvalidUsernameException | UsernameExistsException ex){
                System.out.println(ex.getMessage());
            }
        }
    }

    public static String takeUsername() throws SQLException {
        System.out.print("Enter username: ");
        String username = input.nextLine();
        return username;
    }


    public static String receiveEmail() throws SQLException {
        while (true) {
            try {
                System.out.print("Enter email: ");
                String email = input.nextLine();
                UserController.validateEmail(email);
                return email;
            } catch (InvalidEmailFormatException | EmailExistsException ex){
                System.out.println(ex.getMessage());
            }
        }
    }

    public static String receivePassword(String username) {
        while (true) {
            try {
                System.out.print("Enter password for " + username + ":");
                String password;
                Console console = System.console();
                if (console != null) {
                    char[] pw = console.readPassword();
                    password = new String(pw);
                } else {
                    password = input.nextLine();
                }
                UserController.validatePassword(password);
                return password;
            } catch (InvalidPasswordException ex){
                System.out.println(ex.getMessage());
            }
        }
    }

    public static void receiveTargetFilename(){
        ManifestDisplay.display();
        
        while (true){
            System.out.print("Enter file name to recover: ");
            String filename;
            filename = input.nextLine();
            System.out.print("Enter timestamp: ");
            String at = input.nextLine();

            selected.put(filename, at);
            String confirm;

            System.out.print("More files?y/n: ");
            confirm = input.nextLine();

            if (confirm.equals("y") || confirm.equals("Y"))
                continue;
            else break;

        }

        SelectiveRecoveryService.setTarget(selected);

    }



}

src/main/java/packages/user/UserController.java
package user;

import exception.userservice.*;
import utils.Logger;
import java.sql.SQLException;


public class UserController {
    private static UserService userService;

    static { // bc static runs when the class is loadded.
        try {
            userService = new UserService();
        } catch ( SQLException ex){
            ex.printStackTrace();
            throw new RuntimeException("Failed to Initialize UserService.");
        }
    }

    public static void validateCredentials( boolean matched ) throws InvalidCredentialsException {
        try {
            if (!matched) throw new InvalidCredentialsException();

        } catch ( InvalidCredentialsException ex) {
            Logger.log("Error", "userservice", ex.toString());
            throw ex;
        }

    }

    public static void validateUsername( String username) throws InvalidUsernameException, SQLException, UsernameExistsException {
        try {
            if (username == null || username.length() < 3 || username.length() > 30) 
                throw new InvalidUsernameException();

            if (userService.getUser(username) != null)
                throw new UsernameExistsException();

        } catch (InvalidUsernameException  ex){
                Logger.log("Error", "userservice", ex.toString());
                throw ex;
        } catch (UsernameExistsException ex){
            Logger.log("Error", "userservice", ex.toString());
            throw ex;
        }

    }

    public static void validateEmail( String email ) throws InvalidEmailFormatException, SQLException, EmailExistsException {
        try {
            String emailPattern = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}$";

            if (!email.matches(emailPattern)) 
                throw new InvalidEmailFormatException();

            if (userService.getUserByEmail(email) != null)
                throw new EmailExistsException();


        }catch (InvalidEmailFormatException ex) {
            Logger.log("Error", "userservice", ex.toString());
            throw ex;
        }catch (EmailExistsException ex){
            Logger.log("Error", "userservice", ex.toString());
            throw ex;
        }

    }

    public static void validatePassword( String password ) throws InvalidPasswordException {
        try  {
            if (password == null || password.length() < 8 || password.length() > 256 )
                throw new InvalidPasswordException();

        } catch (InvalidPasswordException ex){
                Logger.log("Error", "userservice", ex.toString());
                throw ex;

        }

    }
 
}
src/main/java/packages/user/UserService.java
package user;

import exception.userservice.*;
import java.sql.*;
import config.DbConfig;
import utils.*;
import java.io.IOException;


public class UserService {
    private UserModel user;
    private Connection conn;
    
    private static final String CREATE = "CREATE TABLE IF NOT EXISTS users( username TEXT PRIMARY KEY, email TEXT, passwordHash TEXT);";
    private static final String INSERT = "INSERT INTO users(username, email, passwordHash) VALUES (? , ?, ?);";
    private static final String DELETE = "DELETE FROM users WHERE username = ?;";
    private static final String GETPASSWORD = "SELECT passwordHash FROM users WHERE username = ?;";
    private static final String GETEMAIL = "SELECT email FROM users WHERE username = ?;";
    private static final String GETUSER = "SELECT * FROM users WHERE username = ?;";
    private static final String GETUSERBYEMAIL = "SELECT * FROM users WHERE email = ?;";

    private static final String UPDATEUSERNAME = "UPDATE users SET username = ? WHERE username = ?;";
    private static final String UPDATEEMAIL = "UPDATE users SET email = ? WHERE username = ?;";
    private static final String UPDATEPASSWORD = "UPDATE users  SET passwordHash = ? WHERE username = ? ;";


    public UserService() throws SQLException {
        user = new UserModel();
        conn = DbConfig.getConnection("jdbc:sqlite:backup_system.db");
        Statement stmt = conn.createStatement();



        stmt.execute(CREATE);
        stmt.close();

     }

    public void createNewUser() throws SQLException {
        user.setUsername(UserUI.receiveUsername());  
        user.setEmail(UserUI.receiveEmail());
        user.setPassword(UserUI.receivePassword(user.getUsername()));

        PreparedStatement pstmt = conn.prepareStatement(INSERT);

        pstmt.setString(1,user.getUsername());
        pstmt.setString(2, user.getEmail());
        pstmt.setString(3, user.getPasswordHash());

        pstmt.executeUpdate();
        pstmt.close();

        Logger.log("success", "userservice", "User created successfully.");
    }
    // added for automated testing

    public void createNewUser(String username, String email, String password) throws SQLException, InvalidUsernameException, InvalidEmailFormatException, InvalidPasswordException, UsernameExistsException, EmailExistsException {

        UserController.validateUsername(username);
        UserController.validateEmail(email);
        UserController.validatePassword(password);

        user.setUsername(username);  
        user.setEmail(email);
        user.setPassword(password);


        PreparedStatement pstmt = conn.prepareStatement(INSERT);

        pstmt.setString(1,user.getUsername());
        pstmt.setString(2, user.getEmail());
        pstmt.setString(3, user.getPasswordHash());

        pstmt.executeUpdate();
        pstmt.close();

        Logger.log("success", "userservice", "User created successfully.");
    }

    public void userLoggin(String username) throws  SQLException, UserNotFoundException,  InvalidCredentialsException, IOException {
        user.setUsername(username);

        String rawPassword = UserUI.receivePassword(user.getUsername()); 

        PreparedStatement pstmt = conn.prepareStatement(GETPASSWORD);
        pstmt.setString(1, user.getUsername());

        ResultSet rs = pstmt.executeQuery();

        if (!rs.next()) throw new UserNotFoundException();

        boolean matched = EncryptionUtils.verifyPassword(rawPassword, rs.getString("passwordHash"));

        rs.close();
        pstmt.close();


        UserController.validateCredentials(matched);
            
        Logger.log("success", "userservice", "login successfull.");
        SessionManager.startSession(user.getUsername());   
    }

    // overloaded login method for testing

    public void userLoggin(String username, String password) 
        throws  SQLException, UserNotFoundException,  InvalidCredentialsException, IOException 
    {
        user.setUsername(username);
        String rawPassword = password; 

        PreparedStatement pstmt = conn.prepareStatement(GETPASSWORD);
        pstmt.setString(1, user.getUsername());

        ResultSet rs = pstmt.executeQuery();

        if (!rs.next()) throw new UserNotFoundException();

        boolean matched = EncryptionUtils.verifyPassword(rawPassword, rs.getString("passwordHash"));

        rs.close();
        pstmt.close();


        UserController.validateCredentials(matched);
            
        Logger.log("success", "userservice", "login successfull.");
        SessionManager.startSession(user.getUsername());   

    }


    public  UserModel getUser( String username ) throws SQLException {
        UserModel user = new UserModel();
        PreparedStatement pstmt = conn.prepareStatement(GETUSER);
        pstmt.setString(1, username);

        ResultSet rs = pstmt.executeQuery();

        if (!rs.next()) return null;
        else {
            user.setUsername(rs.getString("username"));
            user.setEmail(rs.getString("email"));
            user.setPasswordHash(rs.getString("passwordHash"));

            pstmt.close();
            rs.close();
            
            // added for test.
            System.out.println(user.getUsername() + " " + user.getEmail() + " " + user.getPasswordHash() + " ");

            return user;
        }

    }



    public UserModel getUserByEmail( String email )  throws SQLException  {
        UserModel user = new UserModel();
        PreparedStatement pstmt = conn.prepareStatement(GETUSERBYEMAIL);
        pstmt.setString(1, email);

        ResultSet rs = pstmt.executeQuery();

        if (!rs.next()) return null;
        else {
            user.setUsername(rs.getString("username"));
            user.setEmail(rs.getString("email"));
            user.setPasswordHash(rs.getString("passwordHash"));

            pstmt.close();
            rs.close();
           
            // for testing
            System.out.println(user.getUsername() + " " + user.getEmail() + " " + user.getPasswordHash() + " ");

            return user;
        }


    }

    public void removeUser() throws SQLException, UserNotFoundException, IOException {
       String username;
       username = SessionManager.who();
       if (username == null) throw new UserNotFoundException();

       PreparedStatement pstmt = conn.prepareStatement(DELETE);
       pstmt.setString(1, username);
       pstmt.executeUpdate();
       
       pstmt.close();
       SessionManager.endSession();
        
       Logger.log("success", "userservice", "User Deleted successfully.");

    }
        

    public void updateUsername()  throws SQLException, IOException  {
        user.setUsername(UserUI.receiveUsername()); 

        PreparedStatement pstmt = conn.prepareStatement(UPDATEUSERNAME);

        pstmt.setString(1, user.getUsername());
        pstmt.setString(2, SessionManager.who());

        pstmt.executeUpdate();
        
        pstmt.close();
        Logger.log("success", "userservice", "Username changed successfully.");
    }

    // overloaded updateUsername  method for testing
    //
    public void updateUsername( String username )  throws SQLException, IOException  {
        user.setUsername( username ); 

        PreparedStatement pstmt = conn.prepareStatement(UPDATEUSERNAME);

        pstmt.setString(1, user.getUsername());
        pstmt.setString(2, SessionManager.who());

        pstmt.executeUpdate();
        
        pstmt.close();
        Logger.log("success", "userservice", "Username changed successfully.");
    }



    public void updateEmail()  throws SQLException, IOException {
        user.setEmail(UserUI.receiveEmail()); 

        PreparedStatement pstmt = conn.prepareStatement(UPDATEEMAIL);
        pstmt.setString(1, user.getEmail());
        pstmt.setString(2, SessionManager.who());
        pstmt.executeUpdate();
        
        pstmt.close();
        Logger.log("success", "userservice", "Email changed successfully.");
    }

    // overloaded updateEmail method for testing

    public void updateEmail(String email)  throws SQLException, IOException {
        user.setEmail(email); 

        PreparedStatement pstmt = conn.prepareStatement(UPDATEEMAIL);
        pstmt.setString(1, user.getEmail());
        pstmt.setString(2, SessionManager.who());
        pstmt.executeUpdate();
        
        pstmt.close();
        Logger.log("success", "userservice", "Email changed successfully.");
    }

    public void updatePassword()  throws SQLException , IOException, InvalidCredentialsException, UserNotFoundException {
        String username = null;
        if (SessionManager.who() == null){
            username = UserUI.takeUsername();
            this.userLoggin(username);
            SessionManager.startSession(username);   
        }

        user.setPassword(UserUI.receivePassword(SessionManager.who())); 

        PreparedStatement pstmt = conn.prepareStatement(UPDATEPASSWORD);
        pstmt.setString(1, user.getPasswordHash());
        pstmt.setString(2, SessionManager.who());

        pstmt.executeUpdate();

        pstmt.close();
        Logger.log("success", "userservice", "password changed successfully.");
    }
    
    // overloaded updatePassword method for testing

    public void updatePassword( String password )  throws SQLException , IOException {
        user.setPassword(password); 

        PreparedStatement pstmt = conn.prepareStatement(UPDATEPASSWORD);
        pstmt.setString(1, user.getPasswordHash());
        pstmt.setString(2, SessionManager.who());

        pstmt.executeUpdate();

        pstmt.close();
        Logger.log("success", "userservice", "password changed successfully.");
    }


    public void logout() throws IOException {
        SessionManager.endSession();
        Logger.log("success", "userservice", "user Logged out successfully.");

    }


}
src/main/java/packages/user/UserModel.java
package user;

import exception.userservice.*;
import utils.EncryptionUtils;

public class UserModel {
    private String username;
    private String email;
    private String passwordHash;

    public void setUsername(String username) {
        this.username = username;
    }

    public void setEmail(String email)  {
            this.email = email;

    }

    public void setPassword( String password) { 
        this.passwordHash = EncryptionUtils.hashPassword(password);

    }
    public void setPasswordHash(String hashedPassword){
        this.passwordHash = hashedPassword;

    }

    public String getUsername(){
        return this.username;

    }

    public String getEmail(){
        return this.email;

    }

    public String getPasswordHash(){
        return this.passwordHash;
    }

}
src/main/java/packages/storage/StorageManager.java
package storage;

import java.nio.file.Path;
import java.io.IOException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import utils.Queues;
import config.user_config.storage_config.StorageConfigModel;
import utils.Logger;

public class StorageManager {
    public static  int workerCount;
    private final ExecutorService workers;
    private final StorageWriter writer;
    private final StorageConfigModel config;
    private boolean running = false;

    public StorageManager(StorageWriter writer, StorageConfigModel config, int threads) {
        this.writer = writer;
        this.workerCount = threads;
        this.workers = Executors.newFixedThreadPool(workerCount);
        this.config =  config;
    }

    public void start() {
        for (int i = 0; i < workerCount; i++) {
            workers.submit(() -> {
                try {
                    while (true) {
                        Path encrypted = Queues.ENCRYPTED_QUEUE.take();
                        if (encrypted.equals(Queues.POISON)) break;
                        writer.write(config, encrypted);
                        System.out.println(encrypted.getFileName() + " written");
                    }
                } catch (InterruptedException ex) {
                    Thread.currentThread().interrupt();
                } catch (IOException e) {
                    Logger.log("ERROR", "storage", e.getMessage());
                }
            });
        }
    }

    public void stop() throws InterruptedException {
        workers.shutdown();
        workers.awaitTermination(1, TimeUnit.HOURS);
    }

}

src/main/java/packages/storage/CloudStorageWriter.java
package storage;



import config.user_config.storage_config.StorageConfigModel;
import java.nio.file.Path;
import java.io.IOException;

public class CloudStorageWriter implements StorageWriter {
    // implementetion on version 2 
    @Override
    public void write(StorageConfigModel config, Path file) throws IOException {
    }
}

src/main/java/packages/storage/SFTPStorageWriter.java
package storage;

import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;

import java.io.IOException;
import java.nio.file.Path;

import config.user_config.storage_config.StorageConfigModel;
import utils.connection.SFTPConnectionHandler;
import exception.connection.ConnectionTestException;

public class SFTPStorageWriter implements StorageWriter {

    @Override
    public void write(StorageConfigModel config, Path encryptedFile) throws IOException {
        Session session = null;
        ChannelSftp sftp = null;

        try {
            session = createSession(config);
            System.out.println("seession created");
            try {
            sftp = (ChannelSftp) session.openChannel("sftp");
            
            sftp.connect();

            } catch (Exception ex){
                System.out.println("Failed to open channel: " + ex );
                throw ex;
            }
            System.out.println("channel opened");
            String remoteDir = config.getPath(); 
            ensureRemoteDirectory(remoteDir, sftp);

            String remoteFile = remoteDir + "/" + encryptedFile.getFileName().toString();

            sftp.put(encryptedFile.toString(), remoteFile, ChannelSftp.OVERWRITE);
            System.out.println("Uploaded: " + remoteFile);

        } catch (Exception ex) {
            System.out.println("SFTP upload error: " + ex);
            throw new RuntimeException("Failed to upload via SFTP: " + ex, ex);

        } finally {
            if (sftp != null && sftp.isConnected()) sftp.disconnect();
            if (session != null && session.isConnected()) session.disconnect();
        }
    }

    private Session createSession(StorageConfigModel config) throws ConnectionTestException, IOException {
        if (config.getPasswordPath() != null) {
            String pwd = utils.connection.helpers.CredentialUtils.readPasswordPath(config.getPasswordPath());
            return SFTPConnectionHandler.getSessionByPassword(
                    config.getUser(), config.getHost(), config.getPort(), pwd
            );
        } else {
            return SFTPConnectionHandler.getSessionByPrivateKeyPassKey(
                    config.getUser(),
                    config.getHost(),
                    config.getPrivateKeyPath(),
                    config.getPassPhrase(),
                    config.getPort()
            );
        }
    }

    private void ensureRemoteDirectory(String remoteDir, ChannelSftp sftp) throws SftpException {
        String[] parts = remoteDir.split("/");
        String current = "";
        for (String p : parts) {
            if (p.isBlank()) continue;
            current += "/" + p;
            try {
                sftp.cd(current);
            } catch (SftpException ex) {
                sftp.mkdir(current);
            }
        }
    }
}

src/main/java/packages/storage/StorageWriter.java
package storage;

import java.nio.file.Path;
import java.io.IOException;
import config.user_config.storage_config.StorageConfigModel;

public interface StorageWriter{
    void write(StorageConfigModel Location, Path path) throws IOException;
}
src/main/java/packages/storage/MountedDeviceWriter.java
package storage;

import java.nio.file.Path;
import java.nio.file.Files;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

import config.user_config.storage_config.StorageConfigModel;

public class MountedDeviceWriter implements StorageWriter{
    public void write(StorageConfigModel config, Path encrypted) throws IOException {
        Path destDir = Path.of(config.getMountPoint());

        Files.createDirectories(destDir);

        Path destFile = destDir.resolve(encrypted.getFileName());

        try (var in = Files.newInputStream(encrypted);
             var out = Files.newOutputStream(destFile)) {
            in.transferTo(out);
            System.out.println("Written: " + destFile);
        }
    }
    
}
src/main/java/packages/storage/SFTPStorageReader.java
package storage;

import java.nio.file.Path;
import java.nio.file.Files;
import java.io.IOException;
import java.util.Vector;

import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;

import config.user_config.storage_config.StorageConfigModel;
import utils.Queues;
import utils.connection.SFTPConnectionHandler;
import exception.connection.ConnectionTestException;
import utils.connection.helpers.CredentialUtils;

public class SFTPStorageReader implements StorageReader {

    @Override
    public void read(StorageConfigModel config, Path downloadDir) throws IOException, InterruptedException {
        Files.createDirectories(downloadDir);

        Session session = null;
        ChannelSftp sftp = null;

        try {
            session = createSession(config);
            sftp = (ChannelSftp) session.openChannel("sftp");
            sftp.connect();

            String remoteDir = config.getPath();
            Vector<ChannelSftp.LsEntry> entries = sftp.ls(remoteDir);

            for (ChannelSftp.LsEntry entry : entries) {
                String name = entry.getFilename();
                if (name.equals(".") || name.equals("..") || !name.endsWith(".enc")) continue;

                Path localFile = downloadDir.resolve(name);
                sftp.get(remoteDir + "/" + name, localFile.toString());
                Queues.ENCRYPTED_QUEUE.put(localFile);
                System.out.println("SFTP file queued: " + localFile.getFileName());
            }

        } catch (Exception ex) {
            throw new IOException("SFTP read failed: " + ex, ex);

        } finally {
            if (sftp != null && sftp.isConnected()) sftp.disconnect();
            if (session != null && session.isConnected()) session.disconnect();
        }

        Queues.ENCRYPTED_QUEUE.put(Queues.POISON); 
    }

    private Session createSession(StorageConfigModel config) throws ConnectionTestException, IOException {
        if (config.getPasswordPath() != null) {
            String pwd = CredentialUtils.readPasswordPath(config.getPasswordPath());
            return SFTPConnectionHandler.getSessionByPassword(
                    config.getUser(), config.getHost(), config.getPort(), pwd
            );
        } else {
            return SFTPConnectionHandler.getSessionByPrivateKeyPassKey(
                    config.getUser(),
                    config.getHost(),
                    config.getPrivateKeyPath(),
                    config.getPassPhrase(),
                    config.getPort()
            );
        }
    }
}

src/main/java/packages/storage/NFSStorageWriter.java
package storage;



import config.user_config.storage_config.StorageConfigModel;
import java.nio.file.Path;
import java.io.IOException;

public class NFSStorageWriter implements StorageWriter {
    // implementetion on version 2 
    @Override
    public void write(StorageConfigModel config, Path file) throws IOException {
    }
}

src/main/java/packages/storage/LocalStorageReader.java
package storage;

import java.nio.file.Path;
import java.nio.file.Files;
import java.nio.file.DirectoryStream;
import java.io.IOException;

import config.user_config.storage_config.StorageConfigModel;
import utils.Queues;

public class LocalStorageReader implements StorageReader {

    @Override
    public void read(StorageConfigModel config, Path downloadDir) throws IOException, InterruptedException {
        Path sourceDir = Path.of(config.getPath());
        if (!Files.exists(sourceDir) || !Files.isDirectory(sourceDir)) {
            throw new IOException("Local backup directory does not exist: " + sourceDir);
        }

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(sourceDir, "*.enc")) {
            for (Path file : stream) {
                Path target = downloadDir.resolve(file.getFileName());
                Files.copy(file, target);
                Queues.ENCRYPTED_QUEUE.put(target);
                System.out.println("Local file queued: " + target.getFileName());
            }
        }

        Queues.ENCRYPTED_QUEUE.put(Queues.POISON);
    }
}

src/main/java/packages/storage/SMBStorageWriter.java
package storage;



import config.user_config.storage_config.StorageConfigModel;
import java.nio.file.Path;
import java.io.IOException;

public class SMBStorageWriter implements StorageWriter {
    // implementetion on version 2 
    @Override
    public void write(StorageConfigModel config, Path file) throws IOException {
    }
}

src/main/java/packages/storage/StorageReader.java
package storage;

import java.io.IOException;
import java.nio.file.Path;

import config.user_config.storage_config.StorageConfigModel;

public interface StorageReader {
    void read(StorageConfigModel config, Path downloadDir) throws IOException, InterruptedException ;
}
src/main/java/packages/storage/LocalStorageWriter.java
package storage;

import java.nio.file.Path;
import java.nio.file.Files;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

import config.user_config.storage_config.StorageConfigModel;


public class LocalStorageWriter implements StorageWriter {
    @Override
    public void write(StorageConfigModel config, Path encrypted) throws IOException {
        Path destDir = Path.of(config.getPath());

        Files.createDirectories(destDir);

        Path destFile = destDir.resolve(encrypted.getFileName());

        try (var in = Files.newInputStream(encrypted);
             var out = Files.newOutputStream(destFile)) {
            in.transferTo(out);
            System.out.println("Written: " + destFile);
        }
    }
}

src/main/java/packages/recovery/FullRecoveryService.java
package recovery;

import java.nio.file.Path;
import java.nio.file.Files;
import java.nio.file.DirectoryStream;
import java.io.IOException;

import utils.compdecomp.FileUtils;
import utils.compdecomp.Compressable;
import utils.compdecomp.GzipCompressor;
import utils.encdecrypt.EncryptionAdapter;
import utils.encdecrypt.EncryptionHandler;
import utils.encdecrypt.DecryptorService;
import utils.Queues;

import config.user_config.storage_config.StorageConfigModel;
import config.user_config.storage_config.ConfigService;

import storage.LocalStorageReader;
import storage.SFTPStorageReader;
import utils.Logger;

public class FullRecoveryService implements Recoveryable {
    int workers = 3;

    @Override
    public void recover() throws Exception {

        Path recoveryWorkspace = Path.of("backup_workspace/temp/recovery/");
        Path downloadDir = Path.of("backup_workspace/temp/recovery_download/");

        FileUtils.ensureDir(recoveryWorkspace);
        FileUtils.ensureDir(downloadDir);

        StorageConfigModel conf = ConfigService.getConfig();

        EncryptionHandler handler =
            EncryptionHandler.fromBase64Key(conf.getEncryptionKey());
        EncryptionAdapter.setHandler(handler);

        switch (conf.getType()) {
            case LOCAL:
            case EXTERNAL:
            case PARTITION:
                new LocalStorageReader().read(conf, downloadDir);
                break;
            case SFTP:
                new SFTPStorageReader().read(conf, downloadDir);
                break;
            default:
                throw new UnsupportedOperationException(
                        "Unsupported storage type: " + conf.getType());
        }

        try (DirectoryStream<Path> stream =
                Files.newDirectoryStream(downloadDir, "*.enc")) {

            for (Path enc : stream) {
                Queues.ENCRYPTED_QUEUE.put(enc);
                System.out.println("Queued encrypted file: " + enc.getFileName());
            }
                }

        Queues.ENCRYPTED_QUEUE.put(Queues.POISON);

        DecryptorService decryptor = new DecryptorService(workers);
        decryptor.start();

        Compressable decompressor = new GzipCompressor();

        while (workers > 0) {
            Path decrypted = Queues.DECRYPTED_QUEUE.take();

            if (decrypted.equals(Queues.POISON)) {
                workers--;
                continue;
            }

            decompressor.decompress(decrypted, recoveryWorkspace);
            System.out.println("decompressed: " + decrypted.getFileName());

        }

        decryptor.stop();

        System.out.println("Full recovery completed at " + recoveryWorkspace);

        FileUtils.cleanup(Path.of("backup_workspace/temp/decrypted"));
        FileUtils.cleanup(Path.of("backup_workspace/temp/compressed"));
        FileUtils.cleanup(Path.of("backup_workspace/temp/recovery_download"));
        Logger.log("SUCCESS", "recovery", "recovery completed successfuly.");
    }

}

src/main/java/packages/recovery/RecoveryController.java
package recovery;

public class RecoveryController<T extends Recoveryable> {

    private final T recoveryService;

    public RecoveryController(T recoveryService) {
        this.recoveryService = recoveryService;
    }

    public void runRecovery() throws Exception {
        try {
            recoveryService.recover();
        } catch (Exception ex) {
            throw ex;
        }
    }
}

src/main/java/packages/recovery/Recovery.java
package recovery;
import utils.compdecomp.FileUtils;
import java.nio.file.Path;

public class Recovery {
    public static void recover(RecoveryModel.Type type) {
        try {
            Recoveryable service = RecoveryServiceResolver.getService(type);
            RecoveryController controller = new RecoveryController(service);
            controller.runRecovery();

            System.out.println("Recovery daemon running...");
        } catch (Exception ex) {
            System.out.println("Error: " + ex);
            FileUtils.cleanup(Path.of("backup_workspace/temp/decrypted"));
            FileUtils.cleanup(Path.of("backup_workspace/temp/compressed"));
            FileUtils.cleanup(Path.of("backup_workspace/temp/recovery_download"));
        }
    }
}

src/main/java/packages/recovery/SelectiveRecoveryService.java
package recovery;

import java.nio.file.Path;
import java.nio.file.Files;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

import utils.compdecomp.FileUtils;
import utils.compdecomp.Compressable;
import utils.compdecomp.GzipCompressor;
import utils.encdecrypt.EncryptionAdapter;
import utils.encdecrypt.EncryptionHandler;

import config.user_config.storage_config.StorageConfigModel;
import config.user_config.storage_config.ConfigService;

import storage.LocalStorageReader;
import storage.SFTPStorageReader;

import user.UserUI;
import utils.Logger;

public class SelectiveRecoveryService implements Recoveryable {

    private static Map<String, String> target = new HashMap<>();


    public static void setTarget(Map<String, String> t) {
        target.clear();
        target.putAll(t);
    }


    @Override
    public void recover() throws Exception {

        //UserUI.receiveTargetFilename();

        Path recoveryWorkspace = Path.of("backup_workspace/temp/recovery_selective/");
        FileUtils.ensureDir(recoveryWorkspace);

        StorageConfigModel conf = ConfigService.getConfig();
        Path downloadDir = Path.of("backup_workspace/temp/recovery_download/");

        FileUtils.ensureDir(downloadDir);

        String base64Key = conf.getEncryptionKey();
        EncryptionHandler encryptionHandler = EncryptionHandler.fromBase64Key(base64Key);
        EncryptionAdapter.setHandler(encryptionHandler);

        switch (conf.getType()) {
            case LOCAL, EXTERNAL, PARTITION -> new LocalStorageReader().read(conf, downloadDir);
            case SFTP -> new SFTPStorageReader().read(conf, downloadDir);
            default -> throw new UnsupportedOperationException("Unsupported storage type: " + conf.getType());
        }

        List<Path> filesToRecover = new ArrayList<>();

        for (Map.Entry<String, String> entry : target.entrySet()) {
            String targetFilename = entry.getKey();
            String targetTimestamp = entry.getValue();

            for (Path file : Files.list(downloadDir).toList()) {
                String filename = file.getFileName().toString();

                if (
                    filename.startsWith(targetFilename + "_") &&
                    filename.endsWith(".gz.enc") &&
                    filename.contains(targetTimestamp)
                ) {
                    filesToRecover.add(file);
                    System.out.println("Matched encrypted file: " + filename);
                }
            }
        }

        if (filesToRecover.isEmpty()) {
            System.out.println("No matching files found for selective recovery.");
            return;
        }

        List<Path> decryptedFiles = new ArrayList<>();

        try {
            for (Path encFile : filesToRecover) {
                Path decrypted = EncryptionAdapter.decrypt(encFile);
                decryptedFiles.add(decrypted);
                System.out.println("File decrypted: " + decrypted.getFileName());
            }

            Compressable decompressor = new GzipCompressor();
            for (Path decrypted : decryptedFiles) {
                decompressor.decompress(decrypted, recoveryWorkspace);
                System.out.println("Decompressed: " + decrypted.getFileName());
            }
        } finally {
            FileUtils.cleanup(downloadDir);

        }

        System.out.println("Temporary directories cleaned up.");

        System.out.println("Selective recovery completed at " + recoveryWorkspace);
        Logger.log("SUCCESS", "recovery", "recovery completed successfuly.");

    }
}

src/main/java/packages/recovery/RecoveryModel.java
package recovery;

public class RecoveryModel {
    public enum Type {FULL, SELECTIVE}
    private Type type;

    public void setType(Type type) { this.type = type; }
    public Type getType() { return type; }
}

src/main/java/packages/recovery/Recoveryable.java
package recovery;

public interface Recoveryable {
    void recover() throws Exception;
}

src/main/java/packages/recovery/RecoveryServiceResolver.java
package recovery;

public class RecoveryServiceResolver {

    public static Recoveryable getService(RecoveryModel.Type type) throws Exception {
        switch (type) {
            case FULL:
                return new FullRecoveryService();
            case SELECTIVE:
                return new SelectiveRecoveryService();
            default:
                throw new UnsupportedOperationException("Unsupported Operation: " + type);
        }
    }
}

src/main/java/packages/backup/BackupController.java
package backup;


public class BackupController<T extends Backupable> {

    private final T backupService;

    public BackupController(T backupService) {
        this.backupService = backupService;
    }

    public void runBackup() throws Exception {
        try {
        backupService.backup();
        } catch (Exception ex) {
            throw ex;
        }
    }
}

src/main/java/packages/backup/BackupScheduler.java
package backup;

import java.time.*;

import config.user_config.schedule_config.*;

public class BackupScheduler {

    public boolean isTime() throws Exception {
        try {
            BackupScheduleConfigModel.Frequency freq = ConfigService.getFrequency();

            ZonedDateTime nextRun = ConfigService.getNextRuntime();
            ZonedDateTime now = ZonedDateTime.now(nextRun.getZone()); 
            System.out.println("now: " + now + "\tnext" + nextRun);
            // same zone

            switch (freq) {
                case WEEKLY:
                case MONTHLY:
                case ONCE:
                    return sameDateAndTime(now, nextRun);

                case DAILY:
                case HOURLY:
                case INTERVAL:
                    return sameTime(now, nextRun);

                default:
                    return false;
            }
        } catch (Exception ex){
            throw ex;
        }
    }

    private boolean sameDateAndTime(ZonedDateTime now, ZonedDateTime run) {
        return  now.getDayOfMonth() == run.getDayOfMonth() &&
                now.getHour() == run.getHour() &&
                now.getMinute() == run.getMinute();
    }

    private boolean sameTime(ZonedDateTime now, ZonedDateTime run) {
        return now.getHour() == run.getHour() &&
               now.getMinute() == run.getMinute();
    }
}



src/main/java/packages/backup/PredictiveBackupService.java
package backup;


public class PredictiveBackupService implements Backupable {
    public void backup() throws Exception {}
}
src/main/java/packages/backup/BackupModel.java
package backup;

public class BackupModel {
    public enum Type {FULL, INCREMENTAL, PREDICTIVE };
    private Type type;

    public void setType(Type type) { this.type = type; }
    public Type getType() { return type; }
}
src/main/java/packages/backup/BackupDaemon.java
package backup;


import utils.Logger;
import config.user_config.schedule_config.*;
import java.time.ZonedDateTime;

public class BackupDaemon implements Runnable {

    private final BackupScheduler scheduler;
    private final BackupController controller;

    private static volatile boolean running = true;

    public BackupDaemon(BackupScheduler scheduler, BackupController controller) {
        this.scheduler = scheduler;
        this.controller = controller;
    }

    @Override
    public void run() {
        try {
            while (running) {

                ZonedDateTime nextRun = ConfigService.getNextRuntime();
                long sleepMillis = java.time.Duration
                        .between(ZonedDateTime.now(ConfigService.zone), nextRun)
                        .toMillis();

                if (sleepMillis > 0) {
                    Thread.sleep(sleepMillis);
                }

                if (!running) break;
                
                System.out.println("before backup");
                controller.runBackup();
                System.out.println("Afeter backup");
                ConfigService.lastRun = ZonedDateTime.now(ConfigService.zone);

                Logger.log(
                    BackupScheduleConfigModel.Status.SUCCESS.name(),
                    "backup",
                    "Backup completed at " + ConfigService.lastRun
                );
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            Logger.log(
                BackupScheduleConfigModel.Status.FAILED.name(),
                "backup",
                "Daemon interrupted"
            );
        } catch (Exception e) {
            Logger.log(
                BackupScheduleConfigModel.Status.FAILED.name(),
                "backup",
                e.getMessage()
            );
        }
    }

    public static void stop() {
        running = false;
    }
}

src/main/java/packages/backup/Backupable.java
package backup;

public interface Backupable {
    void backup() throws Exception;
}
src/main/java/packages/backup/BackupServiceResolver.java
package backup;


public class BackupServiceResolver {

    public static Backupable  getService(BackupModel.Type type) throws Exception {
        try {
            switch (type) {
                case FULL:
                    return new FullBackupService();
                case INCREMENTAL:
                    return new IncrementalBackupService();
                case PREDICTIVE:
                    return new PredictiveBackupService();
                default:
                    throw new UnsupportedOperationException(
                            "Unsupported Operation: " + type
                            );
            }
        } catch (Exception ex){
            throw ex;
        }
    }
}

src/main/java/packages/backup/Backup.java
package backup;


import utils.Logger;
import config.user_config.schedule_config.BackupScheduleConfigModel;

public class Backup {
    public static void backup(BackupModel.Type type) {
        if (type == null)
            type = BackupModel.Type.INCREMENTAL;

        try {

        Backupable backupService =  BackupServiceResolver.getService(type);
        BackupScheduler scheduler = new BackupScheduler();
        BackupController controller = new BackupController(backupService);

        Thread daemon = new Thread(new BackupDaemon(scheduler, controller));
        daemon.setDaemon(false); 
        daemon.start();

        System.out.println("Backup daemon running...");
        } catch (Exception ex){
            Logger.log(BackupScheduleConfigModel.Status.FAILED.name(), "backup", ex.getMessage());

            System.out.println("Error: form main " + ex);
        }
    }
}

src/main/java/packages/backup/FullBackupService.java
package backup;

import java.nio.file.Path;
import java.util.Set;

import config.user_config.file_config.BackupFilesConfigModel;
import config.user_config.file_config.ConfigService; 
import config.user_config.storage_config.StorageConfigModel;
import config.user_config.schedule_config.BackupScheduleConfigModel;

import utils.compdecomp.GzipCompressor;
import utils.compdecomp.CompressionManager;
import utils.connection.*;
import utils.connection.helpers.*;
import utils.encdecrypt.*;
import storage.*;
import utils.Logger;
import utils.compdecomp.FileUtils;

public class FullBackupService implements Backupable {

    @Override
    public void backup() throws Exception {
        try {
            BackupFilesConfigModel fileConfig =
                config.user_config.file_config.ConfigService.getConfig();

            Set<String> srcDirs = fileConfig.getSourcePaths();
            Set<String> includePatterns = fileConfig.getIncludePatterns();
            boolean recursive = fileConfig.getRecursive();

            StorageConfigModel conf =
                config.user_config.storage_config.ConfigService.getConfig();
        
            StorageConfigModel.Type type = conf.getType();

            String base64Key = conf.getEncryptionKey();
            EncryptionHandler encryptionHandler = EncryptionHandler.fromBase64Key(base64Key);
            EncryptionAdapter.setHandler(encryptionHandler);

            CompressionManager compressor = new CompressionManager(
                    new GzipCompressor(),
                    Path.of("backup_workspace/temp/compressed/"),
                    2,
                    BackupModel.Type.FULL
                    );

            EncrypterService encrypter = new EncrypterService(2);
            StorageManager storageManager = null;

            switch (type){
                case LOCAL:
                    storageManager = new StorageManager(
                            new LocalStorageWriter(),
                            conf,
                            2
                            );
                    break;
                case EXTERNAL:
                case PARTITION: 
                    storageManager = new StorageManager(
                            new MountedDeviceWriter(),
                            conf,
                            2
                            );
                    break;
                case SMB:
                    storageManager = new StorageManager(
                            new SMBStorageWriter(),
                            conf,
                            2
                            );
                    break;
                case SFTP:
                    System.out.println("inside sftp writer");
                    System.out.println(config.user_config.storage_config.ConfigService.testConnection());
                    storageManager = new StorageManager(
                            new SFTPStorageWriter(),
                            conf,
                            2);
                    break;
                default:
                    throw new UnsupportedOperationException(
                        "Unsupported Operation: " + type);

            }

            encrypter.start();
            storageManager.start();

            compressor.compressAll(srcDirs, includePatterns, recursive);


            encrypter.stop();
            storageManager.stop();

            System.out.println("Full backup completed.");
            Logger.log(BackupScheduleConfigModel.Status.SUCCESS.name(), "backup", "backup completed successfully.");

            FileUtils.cleanup(Path.of("backup_workspace/temp/compressed"));

        } catch (Exception ex) {
            throw ex;
        }
    }

}

src/main/java/packages/backup/IncrementalBackupService.java
package backup;

import java.nio.file.Path;
import java.nio.file.Files;
import java.io.IOException;
import java.util.Set;
import java.util.List;
import java.util.HashSet;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.JsonNode;

import config.user_config.file_config.BackupFilesConfigModel;
import config.user_config.file_config.ConfigService;
import config.user_config.storage_config.StorageConfigModel;

import utils.compdecomp.*;
import utils.encdecrypt.*;

import storage.StorageManager;
import storage.LocalStorageWriter;
import storage.MountedDeviceWriter;
import storage.SMBStorageWriter;
import storage.SFTPStorageWriter;
import utils.Logger;
import config.user_config.schedule_config.BackupScheduleConfigModel;


public class IncrementalBackupService implements Backupable {

    private static final Path MANIFEST_PATH = Path.of("backup_workspace/temp/archive/manifest.json");

    @Override
    public void backup() throws Exception {
        try {
            BackupFilesConfigModel fileConfig = ConfigService.getConfig();
            Set<String> srcDirs = fileConfig.getSourcePaths();
            Set<String> includePatterns = fileConfig.getIncludePatterns();
            boolean recursive = fileConfig.getRecursive();

            StorageConfigModel storageConfig = config.user_config.storage_config.ConfigService.getConfig();
            StorageConfigModel.Type storageType = storageConfig.getType();

            String base64Key = storageConfig.getEncryptionKey();
            EncryptionHandler encryptionHandler = EncryptionHandler.fromBase64Key(base64Key);
            EncryptionAdapter.setHandler(encryptionHandler);

            Set<String> backedUpHashes = loadManifestHashes(MANIFEST_PATH);

            CompressionManager compressor = new CompressionManager(
                    new GzipCompressor(),
                    Path.of("backup_workspace/temp/compressed/"),
                    2,
                    BackupModel.Type.INCREMENTAL
            );

            EncrypterService encrypter = new EncrypterService(2);

            StorageManager storageManager = switch (storageType) {
                case LOCAL -> new StorageManager(new LocalStorageWriter(), storageConfig, 2);
                case EXTERNAL, PARTITION -> new StorageManager(new MountedDeviceWriter(), storageConfig, 2);
                case SMB -> new StorageManager(new SMBStorageWriter(), storageConfig, 2);
                case SFTP -> new StorageManager(new SFTPStorageWriter(), storageConfig, 2);
                default -> throw new UnsupportedOperationException("Unsupported Operation: " + storageType);
            };

            Set<Path> filesToBackup = new HashSet<>();
            for (String srcDir : srcDirs) {
                for (String pattern : includePatterns) {
                    List<Path> files = utils.compdecomp.FileUtils.findFiles(Path.of(srcDir), pattern, recursive);
                    for (Path file : files) {
                        String hash = utils.compdecomp.FileHashing.sha256(file);
                        if (!backedUpHashes.contains(hash)) {
                            filesToBackup.add(file);
                        }
                    }
                }
            }

            encrypter.start();
            storageManager.start();

            compressor.compressFiles(filesToBackup);

            encrypter.stop();
            storageManager.stop();

            System.out.println("Incremental backup completed.");
            Logger.log(BackupScheduleConfigModel.Status.SUCCESS.name(), "backup", "Incremental backup completed successfully.");

            FileUtils.cleanup(Path.of("backup_workspace/temp/compressed"));

        } catch (Exception ex) {
            Logger.log(BackupScheduleConfigModel.Status.FAILED.name(), "backup", ex.getMessage());
            throw ex;
        }
    }

    private Set<String> loadManifestHashes(Path manifestPath) throws IOException {
        Set<String> hashes = new HashSet<>();
        if (!Files.exists(manifestPath)) return hashes;

        try {
            ObjectMapper mapper = new ObjectMapper();
            JsonNode root = mapper.readTree(manifestPath.toFile());
            JsonNode entries = root.get("entries");
            if (entries != null && entries.isArray()) {
                for (JsonNode entry : entries) {
                    String hash = entry.get("hash").asText();
                    hashes.add(hash);
                }
            }
        } catch (IOException ex) {
            Logger.log("ERROR","Failed to read manifest", ex.getMessage());
            throw ex;
        }

        return hashes;
    }
}

src/main/java/config/user_config/UserConfigLoader.java

package config.user_config;

import config.YamlLoader;
import java.time.DayOfWeek;
import java.util.Set;
import java.util.TreeSet;
import config.user_config.schedule_config.*;
import config.user_config.file_config.*;
import config.user_config.storage_config.*;

public class UserConfigLoader extends YamlLoader<RootConfig> {

    public UserConfigLoader() throws IllegalArgumentException {
        super(RootConfig.class, "config.yaml");
    }

    @Override
    public RootConfig loadDefault() {

        RootConfig root = new RootConfig();

        // for scheduler
        BackupScheduleConfigModel schedule = new BackupScheduleConfigModel();
        schedule.setEnabled(true);
        schedule.setFrequency(BackupScheduleConfigModel.Frequency.WEEKLY);

        Set<DayOfWeek> days = new TreeSet<>();
        days.add(DayOfWeek.MONDAY);
        schedule.setDaysOfWeek(days);

        schedule.setHours(6);
        schedule.setMinutes(0);
        schedule.setTimezone("Africa/Addis_Ababa");
        schedule.setRecoveryPolicy(BackupScheduleConfigModel.Policy.SKIP);

        // for file selector
        BackupFilesConfigModel file = new BackupFilesConfigModel();
        file.setSourcePaths(new TreeSet<>(Set.of("/home/gamma/")));
        file.setIncludePatterns(new TreeSet<>(Set.of("*.db", "*.log", "*.config")));
        file.setExcludePatterns(new TreeSet<>(Set.of("*.tmp", "./cache")));
        file.setFollowSymlinks(false);

        //for storage path selection

        StorageConfigModel storage = new StorageConfigModel();
        storage.setType(StorageConfigModel.Type.LOCAL);
        storage.setPath("~/Documents");

        System.out.println(storage.getType()+ " " +  storage.getPath());
        root.setSchedule(schedule);
        root.setFiles(file);
        root.setStorage(storage);

        return root;
    }
}

src/main/java/config/user_config/RootConfig.java
package config.user_config;

import config.user_config.schedule_config.*;
import config.user_config.file_config.*;
import config.user_config.storage_config.StorageConfigModel;
import config.YamlLoader;

public class RootConfig {

    private BackupFilesConfigModel files;
    private BackupScheduleConfigModel schedule;
    private StorageConfigModel storage;

    public BackupFilesConfigModel getFiles() {
        return files;
    }

    public void setFiles(BackupFilesConfigModel files) {
        this.files = files;
    }

    public BackupScheduleConfigModel getSchedule() {
        return schedule;
    }

    public void setSchedule(BackupScheduleConfigModel schedule) {
        this.schedule = schedule;
    }

    public StorageConfigModel getStorage(){
        return storage;
    }

    public void setStorage(StorageConfigModel storage){
        this.storage = storage;
    }
}

src/main/java/config/user_config/storage_config/ConfigService.java
package config.user_config.storage_config;

import config.user_config.*;
import utils.connection.ConnectionTester;
import exception.connection.ConnectionTestException;

public class ConfigService { 
    private static StorageConfigModel config;
    private static RootConfig root;

    static {
        try {
            UserConfigLoader loader = new UserConfigLoader();
            root = loader.load();
            config = root.getStorage();

            ConfigValidator.validate(config);

        } catch (Exception ex) {
            System.err.println("ConfigService failed to initialize: " + ex);
            config = null;
        }
    }

    public static boolean testConnection() throws ConnectionTestException {
        if (config == null) return false; 
            ConnectionTester tester = new ConnectionTester(config);
        return tester.auth(); 
    }
    
    public static StorageConfigModel.Type getDestinationType(){
        return config.getType();
    }
    
    public static StorageConfigModel getConfig(){
        return config;
    }
    public static String getLocalDest(){
        return config.getPath();
    }

}

src/main/java/config/user_config/storage_config/StorageConfigModel.java
package config.user_config.storage_config;

public class StorageConfigModel {

    public static enum Type { LOCAL, EXTERNAL, PARTITION, SMB, NFS, SFTP, CLOUD }

    private Type type;
    private String path;
    private String mountPoint;
    private String host;
    private String share;
    private String user;
    private String passwordPath;
    private String remotePath;
    private String localMount;
    private String privateKeyPath;
    private String provider;
    private String bucket;
    private String accessKey;
    private String secretKey;
    private String passPhrase;
    private int port;
    private String encryptionKey;

    public void setType(Type type) { this.type = type; }
    public void setPath(String path) { this.path = path; }
    public void setMountPoint(String mountPoint) { this.mountPoint = mountPoint; }
    public void setHost(String host) { this.host = host; }
    public void setShare(String share) { this.share = share; }
    public void setUser(String user) { this.user = user; }
    public void setPasswordPath(String passwordPath) { this.passwordPath = passwordPath; }
    public void setRemotePath(String remotePath) { this.remotePath = remotePath; }
    public void setLocalMount(String localMount) { this.localMount = localMount; }
    public void setPrivateKeyPath(String privateKeyPath) { this.privateKeyPath = privateKeyPath; } 
    public void setProvider(String provider) { this.provider = provider; }
    public void setBucket(String bucket) { this.bucket = bucket; }
    public void setAccessKey(String accessKey) { this.accessKey = accessKey; }
    public void setSecretKey(String secretKey) { this.secretKey = secretKey; }
    public void setPassPhrase(String passPhrase) { this.passPhrase = passPhrase; }
    public void setPort(int port) { this.port = port; }
    public void setEncryptionKey(String encryptionKey) { this.encryptionKey = encryptionKey; }

    public Type getType() { return type; }
    public String getPath() { return path; }
    public String getMountPoint() { return mountPoint; }
    public String getHost() { return host; }
    public String getShare() { return share; }
    public String getUser() { return user; }
    public String getPasswordPath() { return passwordPath; }
    public String getRemotePath() { return remotePath; }
    public String getLocalMount() { return localMount; }
    public String getPrivateKeyPath() { return privateKeyPath; }
    public String getProvider() { return provider; }
    public String getBucket() { return bucket; }
    public String getAccessKey() { return accessKey; }
    public String getSecretKey() { return secretKey; }
    public String getPassPhrase() { return passPhrase; }
    public int getPort() { return port; }
    public String getEncryptionKey() { return encryptionKey; }

    @Override
    public String toString() {
        return "StorageConfigModel{" +
                "type=" + type +
                ", path='" + path + '\'' +
                ", mountPoint='" + mountPoint + '\'' +
                ", host='" + host + '\'' +
                ", share='" + share + '\'' +
                ", user='" + user + '\'' +
                ", passwordPath='" + passwordPath + '\'' +
                ", remotePath='" + remotePath + '\'' +
                ", localMount='" + localMount + '\'' +
                ", privateKeyPath='" + privateKeyPath + '\'' +
                ", provider='" + provider + '\'' +
                ", bucket='" + bucket + '\'' +
                ", accessKey='" + accessKey + '\'' +
                ", secretKey='" + secretKey + '\'' +
                ", passPhrase='" + passPhrase + '\'' +
                ", port=" + port +
                '}';
    }
}

src/main/java/config/user_config/storage_config/ConfigValidator.java
package config.user_config.storage_config;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.Path;

import exception.connection.ConnectionTestException;


public class ConfigValidator {

    public static void validate(StorageConfigModel m) throws IllegalArgumentException , ConnectionTestException {

        StorageConfigModel.Type type = m.getType();

        String path = m.getPath();
        String mountPoint = m.getMountPoint();
        String host = m.getHost();
        String share = m.getShare();
        String user = m.getUser();
        String passwordPath = m.getPasswordPath();
        String remotePath = m.getRemotePath();
        String localMount = m.getLocalMount();
        String privateKey = m.getPrivateKeyPath(); 
        int port = m.getPort();

        if (type == StorageConfigModel.Type.LOCAL) {
            if (isBlank(path) || !isValidPath(path))
                throw new IllegalArgumentException("Invalid path: " + path);
        } 

        if (type == StorageConfigModel.Type.EXTERNAL || type == StorageConfigModel.Type.PARTITION) {
            if (isBlank(mountPoint) || !isValidPath(mountPoint))
                throw new IllegalArgumentException("Invalid mountPoint: " + mountPoint);
        }

        if (type == StorageConfigModel.Type.SMB) {
            if (isBlank(share))
                throw new IllegalArgumentException("SMB requires a share name.");
        }

        if (type == StorageConfigModel.Type.SMB || type == StorageConfigModel.Type.SFTP) {
            if (isBlank(user))
                throw new IllegalArgumentException("User cannot be empty.");
        }

        if (type == StorageConfigModel.Type.NFS) {
            if (isBlank(remotePath))
                throw new IllegalArgumentException("remotePath is required.");
            if (isBlank(localMount) || !isValidPath(localMount))
                throw new IllegalArgumentException("Invalid localMount: " + localMount);
        }

        if (type == StorageConfigModel.Type.SFTP) {
            if (!isBlank(privateKey) && !isValidPath(privateKey))
                throw new IllegalArgumentException("Invalid privateKey: " + privateKey);
            if (port <= 0)
                throw new IllegalArgumentException("Invalid port: " + port);
        }

        if (type == StorageConfigModel.Type.SMB ||
            type == StorageConfigModel.Type.NFS ||
            type == StorageConfigModel.Type.SFTP) {
            if (isBlank(host))
                throw new IllegalArgumentException("Host cannot be empty.");
        }
    }

    private static boolean isBlank(String s) {
        return s == null || s.isBlank();
    }

    private static boolean isValidPath(String path) throws ConnectionTestException { 
        return path != null && Files.exists(Paths.get(path));
    }
}

src/main/java/config/user_config/schedule_config/ConfigService.java
package config.user_config.schedule_config;

import java.time.*;
import java.nio.file.Path;
import java.nio.file.Files;

import config.user_config.*;

public class ConfigService {
    public static ZonedDateTime lastRun; // we keep track of lastrun for the interval backup

    private static BackupScheduleConfigModel m;
    private static RootConfig root;
    public static ZoneId zone;

    static {
        try {
            UserConfigLoader loader = new UserConfigLoader();
            root = loader.load();
            m = root.getSchedule();

            ConfigValidator.validate(m);

            zone = ZoneId.of(m.getTimezone());

        } catch (Exception ex) {
            System.err.println("ConfigService failed to initialize: " + ex);

            m = null;
            zone = ZoneId.systemDefault();
        }
    }

    public static BackupScheduleConfigModel.Status getLastStatus() {
        try {
            return Files.readAllLines(Path.of("backup_system.log"))
                .stream()
                .map(line -> line.split("\\|"))
                .filter(arr -> arr.length >= 4)
                .filter(arr -> arr[1].equals("backup"))
                .reduce((first, second) -> second)     
                .map(arr -> BackupScheduleConfigModel.Status.valueOf(arr[0]))  
                .orElse(BackupScheduleConfigModel.Status.UNKNOWN);

        } catch (Exception ex) {
            return BackupScheduleConfigModel.Status.UNKNOWN;
        }
    }
   
    public static BackupScheduleConfigModel.Frequency getFrequency(){
        return m.getFrequency();
    }

    public static ZonedDateTime getNextRuntime() {

        if (m == null || !m.isEnabled())
            return null;

        ZonedDateTime current = ZonedDateTime.now(zone);

        BackupScheduleConfigModel.Status lastStatus = getLastStatus();

        if (lastStatus == BackupScheduleConfigModel.Status.FAILED ||
            lastStatus == BackupScheduleConfigModel.Status.MISSED) {

            switch (m.getRecoveryPolicy()) {
                case SKIP:
                    break;
                case RUN_IMMEDIATELY:
                    return current;
            }
        }

        switch (m.getFrequency()) {
            case DAILY:
                return daily(current);

            case WEEKLY:
                return weekly(current);

            case MONTHLY:
                return monthly(current);

            case HOURLY:
                return current.plusHours(1)
                              .withMinute(m.getMinutes())
                              .withSecond(0);

            case INTERVAL:
                if (lastRun == null) {
                    lastRun = current;
                    return lastRun;
                }
                ZonedDateTime next = lastRun.plusMinutes(m.getIntervalMinutes());
                if (!next.isAfter(current)) {
                    next = current.plusMinutes(m.getIntervalMinutes()); 
                }
                return next;
            case ONCE:
                return once(current);

            default:
                return null;
        }
    }

    private static ZonedDateTime daily(ZonedDateTime now) {
        ZonedDateTime next = now.withHour(m.getHours())
                                .withMinute(m.getMinutes())
                                .withSecond(0);

        if (next.isBefore(now))
            next = next.plusDays(1);

        return next;
    }

    private static ZonedDateTime weekly(ZonedDateTime now) {
        ZonedDateTime next = null;

        DayOfWeek today = now.getDayOfWeek();

        for (DayOfWeek target : m.getDaysOfWeek()) {

            int diff = target.getValue() - today.getValue();
            if (diff <= 0) diff += 7;

            ZonedDateTime candidate =
                now.plusDays(diff)
                   .withHour(m.getHours())
                   .withMinute(m.getMinutes())
                   .withSecond(0);

            if (next == null || candidate.isBefore(next))
                next = candidate;
        }

        return next;
    }

    private static ZonedDateTime monthly(ZonedDateTime now) {
        ZonedDateTime next = null;

        for (int d : m.getDaysOfMonth()) {

            int safe = safeDay(now, d);

            ZonedDateTime candidate = now.withDayOfMonth(safe)
                                         .withHour(m.getHours())
                                         .withMinute(m.getMinutes())
                                         .withSecond(0);

            if (candidate.isBefore(now)) {
                ZonedDateTime nextMonth = now.plusMonths(1);
                int safeNext = safeDay(nextMonth, d);

                candidate = nextMonth.withDayOfMonth(safeNext)
                                     .withHour(m.getHours())
                                     .withMinute(m.getMinutes())
                                     .withSecond(0);
            }

            if (next == null || candidate.isBefore(next))
                next = candidate;
        }

        return next;
    }

    private static int safeDay(ZonedDateTime now, int day) {
        int last = now.toLocalDate().lengthOfMonth();
        return Math.min(day, last);
    }

    private static ZonedDateTime once(ZonedDateTime now) {
        LocalDate std = LocalDate.parse(m.getStartDate());
        ZonedDateTime t =   std
                           .atStartOfDay(now.getZone())
                           .withHour(m.getHours())
                           .withMinute(m.getMinutes())
                           .withSecond(0);

        if (t.isBefore(now))
            return null;

        return t;
    }

    public static void switchMode() {
        m.setEnabled(!m.isEnabled());
    }
}

src/main/java/config/user_config/schedule_config/BackupScheduleConfigModel.java
package config.user_config.schedule_config;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.util.Set;
import java.util.TreeSet;

public class BackupScheduleConfigModel {

    public enum Frequency { DAILY, WEEKLY, MONTHLY, HOURLY, INTERVAL, ONCE }
    public enum Status { SUCCESS, FAILED, MISSED, UNKNOWN }
    public enum Policy { RUN_IMMEDIATELY, SKIP }

    private Frequency frequency;
    private boolean enabled;
    private int hours;
    private int minutes;
    private String timezone;
    private String startDate; 

    private Set<DayOfWeek> daysOfWeek = new TreeSet<>();
    private Set<Integer> daysOfMonth = new TreeSet<>();

    private int intervalMinutes;
    private Policy recoveryPolicy;

     
    public Frequency getFrequency() { return frequency; }
    public boolean isEnabled() { return enabled; }
    public int getHours() { return hours; }
    public int getMinutes() { return minutes; }
    public String getTimezone() { return timezone; }
    public Set<DayOfWeek> getDaysOfWeek() { return daysOfWeek; }
    public Set<Integer> getDaysOfMonth() { return daysOfMonth; }
    public int getIntervalMinutes() { return intervalMinutes; }

    public String getStartDate() { 
        return startDate != null ? startDate : null; 
    }

    public Policy getRecoveryPolicy() { return recoveryPolicy; }

    public void setFrequency(Frequency frequency) { this.frequency = frequency; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
    public void setHours(int hours) { this.hours = hours; }
    public void setMinutes(int minutes) { this.minutes = minutes; }
    public void setTimezone(String timezone) { this.timezone = timezone; }
    public void setDaysOfWeek(Set<DayOfWeek> daysOfWeek) { this.daysOfWeek = daysOfWeek; }
    public void setDaysOfMonth(Set<Integer> daysOfMonth) { this.daysOfMonth = daysOfMonth; }
    public void setIntervalMinutes(int intervalMinutes) { this.intervalMinutes = intervalMinutes; }
    public void setStartDate(String startDate) { this.startDate = startDate; }
    public void setRecoveryPolicy(Policy recoveryPolicy) { this.recoveryPolicy = recoveryPolicy; }
}

src/main/java/config/user_config/schedule_config/ConfigValidator.java
package config.user_config.schedule_config;

public class ConfigValidator {

    public static void validate(BackupScheduleConfigModel m)
            throws IllegalArgumentException {

        if (m == null)
            throw new IllegalArgumentException("Config is empty or malformed.");

        if (m.getHours() < 0 || m.getHours() > 23)
            throw new IllegalArgumentException("Hour must be 023.");

        if (m.getMinutes() < 0 || m.getMinutes() > 59)
            throw new IllegalArgumentException("Minute must be 059.");

        if (m.getFrequency() == BackupScheduleConfigModel.Frequency.WEEKLY &&
            m.getDaysOfWeek().isEmpty())
            throw new IllegalArgumentException("Weekly schedule requires daysOfWeek.");

        if (m.getFrequency() == BackupScheduleConfigModel.Frequency.MONTHLY) {
            for (int d : m.getDaysOfMonth()) {
                if (d < 1 || d > 31)
                    throw new IllegalArgumentException("Monthly backup days must be 131.");
            }
        }

        if (m.getFrequency() == BackupScheduleConfigModel.Frequency.INTERVAL &&
            m.getIntervalMinutes() <= 0)
            throw new IllegalArgumentException("Interval must be > 0.");
    }
}

src/main/java/config/user_config/file_config/ConfigService.java
package config.user_config.file_config;

import java.util.Set;
import java.util.List;
import java.util.ArrayList;
import config.user_config.*;


public class ConfigService{
    private static BackupFilesConfigModel m;
    private static RootConfig root ;
    static {
        try {
            UserConfigLoader loader = new UserConfigLoader();
            root = loader.load();
            m = root.getFiles();

            ConfigValidator.validate(m);
        } catch (Exception ex) {
            System.err.println("Faild to initailize Loader: " + ex);
            m = null;
        }
    }

    public static BackupFilesConfigModel getConfig() {
        return m;
    }

// for testing
    public static List<Set<String>> getFiles() {
        List<Set<String>> files = new ArrayList<>();
        files.add(m.getSourcePaths());
        files.add(m.getIncludePatterns());
        files.add(m.getExcludePatterns());

        return files;
    }

}
src/main/java/config/user_config/file_config/BackupFilesConfigModel.java
package config.user_config.file_config;

import java.util.Set;
import java.util.TreeSet;

public class BackupFilesConfigModel {

    private Set<String> sourcePaths = new TreeSet<>();
    private Set<String> includePatterns = new TreeSet<>();
    private Set<String> excludePatterns = new TreeSet<>();
    private boolean followSymlinks = false;  
    private final int maxFollowDepth = 10;
    private boolean recursive;

    public void setSourcePaths(Set<String> sourcePaths) {
        this.sourcePaths.clear();
        this.sourcePaths.addAll(sourcePaths);
    }

    public void setIncludePatterns(Set<String> includePatterns) {
        this.includePatterns.clear();
        this.includePatterns.addAll(includePatterns);
    }

    public void setExcludePatterns(Set<String> excludePatterns) {
        this.excludePatterns.clear();
        this.excludePatterns.addAll(excludePatterns);
    }

    public void setFollowSymlinks(boolean followSymlinks) {
        this.followSymlinks = followSymlinks;
    }
    
    public void setRecursive(boolean isRecursive) {
        this.recursive = isRecursive;
    }

    public boolean getRecursive() { return recursive;}

    public Set<String> getSourcePaths() {
        return this.sourcePaths;
    }

    public Set<String> getIncludePatterns() {
        return this.includePatterns;
    }

    public Set<String> getExcludePatterns() {
        return this.excludePatterns;
    }

    public boolean getFollowSymlinks() {
        return this.followSymlinks;
    }

    public int getMaxFollowLink() {
        return this.maxFollowDepth;
    }

    @Override
    public String toString() {
        return "BackupFilesConfigModel {" +
                "\n  sourcePaths=" + sourcePaths +
                ",\n  includePatterns=" + includePatterns +
                ",\n  excludePatterns=" + excludePatterns +
                ",\n  followSymlinks=" + followSymlinks +
                "\n}";
    }
}

src/main/java/config/user_config/file_config/ConfigValidator.java
package config.user_config.file_config;

import java.util.Set;
import java.nio.file.FileSystems;
import java.nio.file.PathMatcher;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.Path;

public class ConfigValidator {
    public static void validate(BackupFilesConfigModel m)
        throws  IllegalArgumentException
    {
         
            Set<String> sources = m.getSourcePaths();
            Set<String> includes = m.getIncludePatterns();
            Set<String> excludes = m.getExcludePatterns();

            if (sources.isEmpty())
                throw new IllegalArgumentException("Source path can't be empty.");

            for (String source : sources){
                if (source.isBlank() || !isValidPath(source))
                    throw new IllegalArgumentException("Invalid Path: " + source);
            }

            if (includes.isEmpty())
                throw new IllegalArgumentException("Include patterns can't be empty.");
            
            for (String include: includes){
                if (include.isBlank() || !isValidFormat(include))
                    throw new IllegalArgumentException("Invalid include pattern: " + include);
            }

            if (excludes.isEmpty())
                throw new IllegalArgumentException("Exclude patterns can't be empty.");

            for (String exclude : excludes){
                if (exclude.isBlank() || !isValidFormat(exclude))
                    throw new IllegalArgumentException("Exclude format can't be empty");
            }
    }

    private static boolean isBlank(String s) {
        return s == null || s.isBlank();
    }


    private static boolean isValidFormat(String pattern)  {
        try {
            PathMatcher p = FileSystems.getDefault().getPathMatcher("glob:" + pattern);
            return true;
        } catch (IllegalArgumentException ex){
            return false;
        }
    }

    private static boolean isValidPath(String path){
      Path p = Paths.get(path);
      return Files.exists(p);

    }

}
src/main/java/config/DbConfig.java
package config;

import java.sql.*;

public class DbConfig {

    static {
        try {
            Class.forName("org.sqlite.JDBC");
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("SQLite JDBC driver not found", e);
        }
    }

    public static Connection getConnection(String url) throws SQLException {
        return DriverManager.getConnection(url);
    }
}

src/main/java/config/YamlLoader.java
package config;

import java.io.*;
import org.yaml.snakeyaml.Yaml;
import org.yaml.snakeyaml.constructor.Constructor;
import org.yaml.snakeyaml.LoaderOptions;

public abstract class YamlLoader<T> {

    private final Class<T> type;
    private final String path;

    public YamlLoader(Class<T> type, String path) {
        this.type = type;
        this.path = path;
    }

    public T load() {
        try (FileInputStream fis = new FileInputStream(path)) {

            LoaderOptions options = new LoaderOptions();
            Yaml yaml = new Yaml(new Constructor(type, options));

            T model = yaml.load(fis);
            return (model != null) ? model : loadDefault();

        } catch (Exception e) {
            System.out.println(e);
            return loadDefault();
        }
    }

    public abstract T loadDefault();
}

src/main/java/utils/EncryptionUtils.java
package utils;
import org.mindrot.jbcrypt.BCrypt;

public class EncryptionUtils{
    public static String hashPassword(String rawData){
        return BCrypt.hashpw(rawData, BCrypt.gensalt());
    }

    public static boolean verifyPassword(String enterdPassword, String storedHash){
        return BCrypt.checkpw(enterdPassword, storedHash);
    }
}


src/main/java/utils/Logger.java
package utils;

import java.io.*;
import java.time.*;
public class Logger {
    private static String PATH = "backup_system.log";
    private static String now = LocalTime.now().toString();

    public static void log(String eventType, String source, String message ) {
        String logMsg = eventType + "|" + source + "|" + message + "|" + now + System.lineSeparator();

        try ( FileWriter fw = new FileWriter(PATH, true)) {
            fw.write(logMsg);
            System.out.println("written to log.");

        } catch (IOException ex){
           System.out.println("Error: " + ex);

        }
    }
}
src/main/java/utils/compdecomp/FileUtils.java
package utils.compdecomp;

import java.nio.file.*;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public final class FileUtils {
    private FileUtils() {}

    public static List<Path> findFiles(Path dir, String globPattern, boolean recursive) throws IOException {
        if (dir == null || !Files.isDirectory(dir)) return List.of();

        String pattern = "glob:" + globPattern;
        PathMatcher matcher = dir.getFileSystem().getPathMatcher(pattern);

        try (Stream<Path> s = recursive ? Files.walk(dir) : Files.list(dir)) {
            return s.filter(Files::isRegularFile)
                    .filter(p -> matcher.matches(p.getFileName()))
                    .distinct() 
                    .filter(p -> !p.getFileName().toString().startsWith(".~lock"))
                    .collect(Collectors.toList());
        }
    }

    public static Path ensureDir(Path dir) throws IOException {
        if (dir == null) throw new IllegalArgumentException("dir must not be null");
        if (!Files.exists(dir)) Files.createDirectories(dir);
        return dir;
    }

    public static Path tempFile(Path dir, String prefix, String suffix) throws IOException {
        ensureDir(dir);
        return Files.createTempFile(dir, prefix, suffix);
    }

    public static void deleteDirectoryRecursively(Path dir) throws IOException {
        if (Files.notExists(dir)) return;

        Files.walk(dir)
             .sorted((a, b) -> b.compareTo(a)) 
             .forEach(path -> {
                 try {
                     Files.delete(path);
                 } catch (IOException e) {
                     throw new RuntimeException("Failed to delete: " + path, e);
                 }
             });
    }

    public  static void cleanup(Path dir) {
        if (Files.exists(dir)) {
            try {
                FileUtils.deleteDirectoryRecursively(dir);
            } catch (IOException e) {
                System.err.println("Failed to clean temp directory " + dir + ": " + e.getMessage());
            }
        }
    }
}

src/main/java/utils/compdecomp/FileHashing.java
package utils.compdecomp;

import java.nio.file.Files;
import java.nio.file.Path;
import java.security.MessageDigest;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;

public final class FileHashing {
    public static String sha256(Path file) throws IOException , NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        md.update(Files.readAllBytes(file));
        return bytesToHex(md.digest());
    }

    private static String bytesToHex(byte[] b) {
        StringBuilder sb = new StringBuilder();
        for (byte x : b) sb.append(String.format("%02x", x));
        return sb.toString();
    }
}

src/main/java/utils/compdecomp/CompressionManager.java
package utils.compdecomp;

import java.nio.file.*;
import java.io.IOException;
import java.util.Set;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import backup.BackupModel;
import utils.Logger;
import utils.Queues;
import utils.manifest.*;
import java.util.Objects;
import java.time.*;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;


public class CompressionManager {

    private final Compressable compressor;
    private final Path tempDir;
    private final ExecutorService workers;
    private ManifestBuilder manifest;
    private String timestamp;
    private static final DateTimeFormatter TS = DateTimeFormatter.ofPattern("yyyyMMddHHmmss");


    public CompressionManager(Compressable compressor, Path tempDir, int threads, BackupModel.Type type) throws IOException {
        this.compressor = Objects.requireNonNull(compressor);
        this.tempDir = Objects.requireNonNull(tempDir);
        this.workers = Executors.newFixedThreadPool(Math.max(1, threads));
        manifest = new ManifestBuilder(Path.of("backup_workspace/temp/archive"),type);

    }

    public void compressAll(Set<String> sources, Set<String> includes, boolean recursive) throws IOException, InterruptedException {
        for (String srcDir : sources) {

            if (srcDir == null) continue;
            for (String pattern : includes) {
                List<Path> files = FileUtils.findFiles(Path.of(srcDir), pattern, recursive);
                for (Path file : files) {
                    final Path f = file;

                    String name = f.getFileName().toString();
                    if (name.startsWith(".")) {
                        System.out.println("Skipping lock file: " + name);
                        continue;
                    }

                    workers.submit(() -> {
                        try {
                            Path compressed = compressor.compress(f, tempDir);
                            timestamp = compressed.getFileName().toString().split("_")[1].split("\\.")[0];

                            Queues.COMPRESSED_QUEUE.put(compressed);
                            manifest.addEntry(new ManifestEntry(
                                        f,
                                        FileHashing.sha256(f),
                                        Files.size(f),
                                        timestamp
                                        ));
                            System.out.println(f + " " + Files.size(f) +  FileHashing.sha256(f) + "\tcompressed");

                        } catch (Exception ex) {
                            Logger.log("ERROR", "compression",ex.getMessage());
                            System.out.println("Error: " + ex);
                        }
                    });
                }
            }
        }



        workers.shutdown();
        if (!workers.awaitTermination(1, TimeUnit.HOURS)) {
            workers.shutdownNow();

        }

        Queues.COMPRESSED_QUEUE.put(Queues.POISON);
        manifest.save();

    }

    public void compressFiles(Set<Path> files) throws IOException, InterruptedException {
        for (Path file : files) {
            if (file == null) continue;

            workers.submit(() -> {
                try {
                    Path compressed = compressor.compress(file, tempDir);
                    Queues.COMPRESSED_QUEUE.put(compressed);
                    timestamp = compressed.getFileName().toString().split("_")[1].split("\\.")[0];

                    manifest.addEntry(new ManifestEntry(
                                file,
                                FileHashing.sha256(file),
                                Files.size(file),
                                timestamp
                                ));

                    System.out.println(file + " compressed");

                } catch (Exception ex) {
                    Logger.log("ERROR", "compression", ex.getMessage());
                }
            });
        }

        workers.shutdown();
        if (!workers.awaitTermination(1, TimeUnit.HOURS)) {
            workers.shutdownNow();
        }

        Queues.COMPRESSED_QUEUE.put(Queues.POISON);
        manifest.save();
    }


}

src/main/java/utils/compdecomp/GzipCompressor.java
package utils.compdecomp;

import java.nio.file.*;
import java.io.*;
import java.util.zip.GZIPOutputStream;
import java.util.zip.GZIPInputStream;
import java.time.format.DateTimeFormatter;
import java.time.ZonedDateTime;
import java.time.ZoneId;
import java.util.Objects;

public class GzipCompressor implements Compressable {

    private static final DateTimeFormatter TS = DateTimeFormatter.ofPattern("yyyyMMddHHmmss");

    @Override
    public Path compress(Path source, Path targetDir) throws IOException {
        Objects.requireNonNull(source);
        Objects.requireNonNull(targetDir);

        if (!Files.isRegularFile(source)) {
            throw new IllegalArgumentException("Source must be a regular file: " + source);
        }

        FileUtils.ensureDir(targetDir);

        String base = source.getFileName().toString();
        String timestamp = ZonedDateTime.now(ZoneId.systemDefault()).format(TS);
        String outName = base + "_" + timestamp + ".gz";

        Path temp = FileUtils.tempFile(targetDir, base + "_" + timestamp, ".tmp");
        Path target = targetDir.resolve(outName);

        try (InputStream in = Files.newInputStream(source);
             OutputStream fout = Files.newOutputStream(temp);
             BufferedOutputStream bout = new BufferedOutputStream(fout);
             GZIPOutputStream gzip = new GZIPOutputStream(bout)) {

            in.transferTo(gzip);
            gzip.finish();
        }

        Files.move(temp, target, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
        return target;
    }

    @Override
    public Path decompress(Path compressedFile, Path targetDir) throws IOException {
        Objects.requireNonNull(compressedFile);
        Objects.requireNonNull(targetDir);

        if (!Files.isRegularFile(compressedFile)) {
            throw new IllegalArgumentException("Source must be a regular file: " + compressedFile);
        }

        FileUtils.ensureDir(targetDir);

        String name = compressedFile.getFileName().toString();
        
        int start = name.length() - 17;
        String ts = name.substring(start, name.length() - 3);

        String filename = name.endsWith(".gz") ? name.substring(0, name.length() - 18) : name;
        String outName = ts + "_" + filename;

        Path temp = FileUtils.tempFile(targetDir, outName, ".tmp");
        Path target = targetDir.resolve(outName);

        try (InputStream fin = Files.newInputStream(compressedFile);
             BufferedInputStream bin = new BufferedInputStream(fin);
             GZIPInputStream gis = new GZIPInputStream(bin);
             OutputStream out = Files.newOutputStream(temp)) {

            gis.transferTo(out);
        }

        Files.move(temp, target, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
        return target;
    }
}

src/main/java/utils/compdecomp/Compressable.java
package utils.compdecomp;

import java.nio.file.Path;
import java.io.IOException;

public interface Compressable {
    Path compress(Path source, Path targetDir) throws IOException;
    Path decompress(Path compressedFile, Path targetDir) throws IOException;

}

src/main/java/utils/connection/SFTPConnectionHandler.java
package utils.connection;

import com.jcraft.jsch.ChannelExec;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;

import java.io.IOException;
import java.util.Objects;

import utils.connection.helpers.CredentialUtils;
import utils.connection.helpers.NetworkUtils;
import exception.connection.*;
import config.user_config.storage_config.StorageConfigModel;

public class SFTPConnectionHandler implements ConnectionHandler {

    private static final int DEFAULT_PORT = 22;
    private static final int CONNECT_TIMEOUT_MS = 5000;

    @Override
    public boolean test(StorageConfigModel config) {
        try {
            String password;
            Session session = null;

            if (config.getPasswordPath() != null ){
                password = CredentialUtils.readPasswordPath(config.getPasswordPath());
                session = getSessionByPassword(config.getUser(), config.getHost(), config.getPort(), password);
            }
            else 

                session = getSessionByPrivateKeyPassKey(config.getUser(), config.getHost(), config.getPrivateKeyPath(),config.getPassPhrase(), config.getPort());
           
            session.disconnect();
   
            return true;
        } catch (Exception ex) {
            System.out.println("Error: " + ex);
            return false;
        }
    }

    public static Session getSessionByPassword(String username, String host, int port, String password)
            throws HostUnreachableException, ConnectionTestException {
            try {
                Objects.requireNonNull(host, "host is required");

                JSch jsch = new JSch();
                int realPort = (port <= 0) ? DEFAULT_PORT : port;

                NetworkUtils.validateHostReachable(host, CONNECT_TIMEOUT_MS);

                if (!NetworkUtils.isPortOpen(host, realPort, CONNECT_TIMEOUT_MS)) {
                    throw new HostUnreachableException(host + "here");
                }

                Session session = jsch.getSession(username != null ? username : "", host, realPort);
                session.setPassword(password);
                session.setConfig("StrictHostKeyChecking", "no");
                session.connect(CONNECT_TIMEOUT_MS);
                return session;

            } catch (JSchException ex) {
                throw new ConnectionTestException("Failed to connect to host: " + host, ex);
            }
    }

    public static Session getSessionByPrivateKeyPassKey( String username, String host, String privateKeyPath, String passPhrase, int port) 
            throws ConnectionTestException, HostUnreachableException {

            try {
                Objects.requireNonNull(username, "username can't be empty");
                Objects.requireNonNull(host, "host can't be empty");
                Objects.requireNonNull(privateKeyPath, "private key path can't be empty");

                int realPort = port <= 0 ? DEFAULT_PORT : port;

                NetworkUtils.validateHostReachable(host, CONNECT_TIMEOUT_MS);
                if (!NetworkUtils.isPortOpen(host, realPort, CONNECT_TIMEOUT_MS)) {
                    throw new HostUnreachableException(host);
                }

                if (!CredentialUtils.fileExists(privateKeyPath)) {
                    throw new ConnectionTestException("Private key file path doesn't exist");
                }

                JSch jsch = new JSch();

                if (passPhrase == null) {
                    jsch.addIdentity(privateKeyPath);
                } else {
                    jsch.addIdentity(privateKeyPath, passPhrase);
                }
                Session session = jsch.getSession(username, host, realPort);
                session.setConfig("StrictHostKeyChecking", "no");
                session.connect(CONNECT_TIMEOUT_MS);

                return session;

            } catch (JSchException ex) {
                throw new ConnectionTestException("Couldn't create session with host: " + host + ":\t" + ex, ex);
            } 
    }

    public static ChannelExec openExecChannel(Session session) throws ConnectionTestException {
        try {
            Objects.requireNonNull(session, "session is required");
            return (ChannelExec) session.openChannel("exec");
        } catch (JSchException ex) {
            throw new ConnectionTestException("Failed to open exec channel.", ex);
        }
    }
}

src/main/java/utils/connection/ConnectionTester.java
package utils.connection;

import config.user_config.storage_config.StorageConfigModel;
import exception.connection.ConnectionTestException;

public class ConnectionTester {  
    private final StorageConfigModel config;

    public ConnectionTester(StorageConfigModel config){
        this.config = config;
    }

    public boolean auth()  throws ConnectionTestException {
        try {
            ConnectionHandler handler = ConnectionHandlerResolver.getHandler(config);
            if (handler == null)
                return false;
            return handler.test(config);
        } catch (Exception ex) {
            throw new ConnectionTestException("Connection Failed.", ex);
        }
    }
}

src/main/java/utils/connection/NFSConnectionHandler.java
package utils.connection;

import config.user_config.storage_config.StorageConfigModel;

public class NFSConnectionHandler implements ConnectionHandler {
     @Override
     public boolean test(StorageConfigModel config){
         return false;
     }
}
src/main/java/utils/connection/helpers/CredentialUtils.java
package utils.connection.helpers;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.charset.StandardCharsets;
import java.io.IOException;

public class CredentialUtils {

    public static String readPasswordPath(String path) throws IOException {
        Path p = Path.of(path); 
        return Files.readAllLines(p, StandardCharsets.UTF_8).get(0).trim(); 
    }

    public static boolean fileExists(String path) {
        return path != null && Files.exists(Path.of(path));
    }
}

src/main/java/utils/connection/helpers/NetworkUtils.java
package utils.connection.helpers;

import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import exception.connection.HostUnreachableException;

public class NetworkUtils {

    private NetworkUtils() {}

    public static void validateHostReachable(String host, int timeout) throws HostUnreachableException {
        try {
            InetAddress.getByName(host); 
        } catch (UnknownHostException ex) {
            throw new HostUnreachableException(host, ex);
        }

        try (Socket s = new Socket()) {
            s.connect(new InetSocketAddress(host, 2222), timeout);
        } catch (IOException ex) {
            throw new HostUnreachableException(host, ex);
        }
    }

    public static boolean isPortOpen(String host, int port, int timeout) {
        try (Socket s = new Socket()) {
            s.connect(new InetSocketAddress(host, port), timeout);
            return true;
        } catch (IOException ex) {
            return false;
        }
    }
}

src/main/java/utils/connection/ConnectionHandler.java
package utils.connection;

import config.user_config.storage_config.StorageConfigModel;

public interface ConnectionHandler {
    boolean test(StorageConfigModel config);
}
src/main/java/utils/connection/CloudConnectionHandler.java
package utils.connection;


import config.user_config.storage_config.StorageConfigModel;
public class CloudConnectionHandler implements ConnectionHandler {
     @Override
     public boolean test(StorageConfigModel config){
         return false;
     }
}
src/main/java/utils/connection/SMBConnectionHandler.java
package utils.connection;

import com.hierynomus.smbj.SMBClient;
import com.hierynomus.smbj.connection.Connection;
import com.hierynomus.smbj.auth.AuthenticationContext;
import com.hierynomus.smbj.session.Session;
import com.hierynomus.smbj.share.DiskShare;

import java.io.IOException;
import java.util.Objects;

import utils.connection.helpers.*;
import exception.connection.*;
import config.user_config.storage_config.StorageConfigModel;

public class SMBConnectionHandler implements ConnectionHandler {

    private static final int PORT = 445;
    private static final int CONNECT_TIMEOUT_MS = 5000;

    @Override
    public boolean test(StorageConfigModel config)  {
        try {
            SMBClient client = openConnection(
                    config.getHost(),
                    config.getUser(),
                    config.getPasswordPath() != null ? CredentialUtils.readPasswordPath(config.getPasswordPath()) : null,
                    config.getShare()
            );
            return closeConnection(client);
        } catch (Exception ex) {
            return false;
        }
    }

    public static SMBClient openConnection(String host, String username, String password, String share)
        throws IOException, Exception , HostUnreachableException {

        Objects.requireNonNull(host, "host is required");
        Objects.requireNonNull(share, "share is required");

        if (!NetworkUtils.isPortOpen(host, PORT, CONNECT_TIMEOUT_MS))
            throw new HostUnreachableException(host);

        SMBClient client = new SMBClient();

        try (Connection connection = client.connect(host)) {

            AuthenticationContext ac = new AuthenticationContext(
                    username != null ? username : "",
                    password != null ? password.toCharArray() : new char[0],
                    null
            );

            Session session = connection.authenticate(ac);

            try (DiskShare disk = (DiskShare) session.connectShare(share)) {
                disk.list("");  
                return client;
            } catch (Exception ex) {
                throw new Exception("Couldn't open share " + share + " on host " + host, ex);
            }

        } catch (IOException ex) {
            throw new Exception("Couldn't connect to remote SMB server", ex);
        } catch (Exception ex) {
            throw new Exception("Authentication failed", ex);
        }
    }

    public static boolean closeConnection(SMBClient client)  {
        try {
            if (client != null) client.close();
            return true;
        } catch (Exception ex) {
            return false;
        }
    } 
}

src/main/java/utils/connection/ConnectionHandlerResolver.java
package utils.connection;

import config.user_config.storage_config.StorageConfigModel;

public class ConnectionHandlerResolver {

    public static ConnectionHandler getHandler(StorageConfigModel config) {
        switch (config.getType()) {
            case SMB:
                return new SMBConnectionHandler();
            case SFTP:
                return new SFTPConnectionHandler();
            case NFS:
                return new NFSConnectionHandler();
            case CLOUD:
                return new CloudConnectionHandler();
            default:
                throw new UnsupportedOperationException(
                        "Unsupported Operation: " + config.getType()
                );
        }
    }
}

src/main/java/utils/Queues.java
package utils;

import java.nio.file.Path;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public final class Queues {
    public static final BlockingQueue<Path> COMPRESSED_QUEUE = new ArrayBlockingQueue<>(256);
    public static final BlockingQueue<Path> ENCRYPTED_QUEUE = new ArrayBlockingQueue<>(256);
    public static final BlockingQueue<Path> DECRYPTED_QUEUE = new ArrayBlockingQueue<>(256);
    public static final Path POISON = Path.of("__POISON__");
}

src/main/java/utils/encdecrypt/DecryptorService.java
package utils.encdecrypt;

import java.nio.file.Path;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import utils.Logger;
import utils.Queues;


  
public class DecryptorService {
    private final int workerCount;
    private final ExecutorService workers;

    public DecryptorService(int workerCount) {
        this.workerCount = Math.max(1, workerCount);
        this.workers = Executors.newFixedThreadPool(this.workerCount);
    }

    public void start() throws Exception {
        for (int i = 0; i < workerCount; i++) {
            workers.submit(() -> {
                try {
                    while (true) {
                        Path encrypted = Queues.ENCRYPTED_QUEUE.take();
                        if (encrypted.equals(Queues.POISON)) {
                            Queues.ENCRYPTED_QUEUE.put(Queues.POISON);
                            Queues.DECRYPTED_QUEUE.put(Queues.POISON);
                            break;
                        }

                        try {
                            Path decrypted = EncryptionAdapter.decrypt(encrypted);
                            Queues.DECRYPTED_QUEUE.put(decrypted);
                        } catch (Exception ex) {
                            Logger.log("Error", "decryption", ex.getMessage());
                        }
                    }
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            });
        }
    }

    public void stop() throws InterruptedException {
        workers.shutdown();
        if (!workers.awaitTermination(1, TimeUnit.MINUTES)) {
            workers.shutdownNow();
        }
    }
}

src/main/java/utils/encdecrypt/EncrypterService.java
package utils.encdecrypt;

import java.nio.file.Path;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import utils.Logger;
import utils.Queues;
import storage.StorageManager;

public class EncrypterService {

    private final int workerCount;
    private final ExecutorService workers;
    private boolean running = false;

    public EncrypterService(int workerCount) {
        this.workerCount = workerCount;
        this.workers = Executors.newFixedThreadPool(workerCount);
    }

    public void start() {
        for (int i = 0; i < workerCount; i++) {
            workers.submit(() -> {
                try {
                    while (true) {
                        Path compressed = Queues.COMPRESSED_QUEUE.take();
                        if (compressed.equals(Queues.POISON)) break;

                        try {
                            Path encrypted = EncryptionAdapter.encrypt(compressed);
                            System.out.println(encrypted.getFileName() + " Encrypted");
                            Queues.ENCRYPTED_QUEUE.put(encrypted);
                        } catch (Exception ex) {
                            Logger.log("Error", "encryption", ex.getMessage());
                        }
                    }
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            });
        }
    }

    public void stop() throws InterruptedException {
        for (int i = 0; i < workerCount; i++) {

            Queues.COMPRESSED_QUEUE.put(Queues.POISON);
        }

        workers.shutdown();
        workers.awaitTermination(1, TimeUnit.HOURS);

        for (int i = 0; i < StorageManager.workerCount; i++) {

            Queues.ENCRYPTED_QUEUE.put(Queues.POISON);
        }
    }

}

src/main/java/utils/encdecrypt/EncryptionHandler.java
package utils.encdecrypt;

import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.SecretKey;
import java.nio.file.*;
import java.security.SecureRandom;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Objects;
import java.util.Base64;

import utils.compdecomp.FileUtils;


public final class EncryptionHandler implements Encryptable {
    private static final int IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH_BITS = 128;

    private final SecretKey key;

    public EncryptionHandler(byte[] keyBytes) {
        Objects.requireNonNull(keyBytes);
        this.key = new SecretKeySpec(keyBytes, "AES");
    }

    public static EncryptionHandler fromBase64Key(String base64Key) {
        byte[] keyBytes = Base64.getDecoder().decode(base64Key);
        return new EncryptionHandler(keyBytes);
    }

    @Override
    public Path encryptFile(Path sourceFile, Path destDir) throws IOException {
        Objects.requireNonNull(sourceFile);
        Objects.requireNonNull(destDir);

        if (!Files.isRegularFile(sourceFile)) {
            throw new IllegalArgumentException("Source must be a file: " + sourceFile);
        }

        try {
            FileUtils.ensureDir(destDir);
        } catch (IOException e) {
            throw new IOException("Cannot create dest dir: " + destDir, e);
        }

        String base = sourceFile.getFileName().toString();
        Path temp = FileUtils.tempFile(destDir, base + "_enc", ".tmp");
        Path target = destDir.resolve(base + ".enc");

        byte[] iv = new byte[IV_LENGTH];
        SecureRandom rnd = new SecureRandom();
        rnd.nextBytes(iv);

        try (InputStream in = Files.newInputStream(sourceFile);
             OutputStream fout = Files.newOutputStream(temp)) {

            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
            cipher.init(Cipher.ENCRYPT_MODE, key, spec);

            fout.write(iv);

            try (java.security.DigestOutputStream ignored = null) {
                try (javax.crypto.CipherOutputStream cos = new javax.crypto.CipherOutputStream(fout, cipher)) {
                    in.transferTo(cos);
                }
            }
        } catch (Exception ex) {
            try { Files.deleteIfExists(temp); } catch (IOException ignored) {}
            throw new IOException("Encryption failed", ex);
        }

        Files.move(temp, target, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
        return target;
    }

    @Override
    public Path decryptFile(Path encryptedFile, Path destDir) throws IOException {
        Objects.requireNonNull(encryptedFile);
        Objects.requireNonNull(destDir);

        if (!Files.isRegularFile(encryptedFile)) {
            throw new IllegalArgumentException("Encrypted file must be a file: " + encryptedFile);
        }

        FileUtils.ensureDir(destDir);

        String name = encryptedFile.getFileName().toString();
        String outName = name.endsWith(".enc") ? name.substring(0, name.length() - 4)  : name ;
        Path temp = FileUtils.tempFile(destDir, outName, ".tmp");
        Path target = destDir.resolve(outName);

        byte[] iv = new byte[IV_LENGTH];

        try (InputStream fin = Files.newInputStream(encryptedFile)) {
            int read = fin.read(iv);
            if (read != IV_LENGTH) throw new IOException("Invalid encrypted file (IV missing)");

            Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
            GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH_BITS, iv);
            cipher.init(Cipher.DECRYPT_MODE, key, spec);

            try (javax.crypto.CipherInputStream cis = new javax.crypto.CipherInputStream(fin, cipher);
                 OutputStream out = Files.newOutputStream(temp)) {
                cis.transferTo(out);
            }
        } catch (Exception ex) {
            try { Files.deleteIfExists(temp); } catch (IOException ignored) {}
            throw new IOException("Decryption failed", ex);
        }

        Files.move(temp, target, StandardCopyOption.ATOMIC_MOVE, StandardCopyOption.REPLACE_EXISTING);
        return target;
    }
}

src/main/java/utils/encdecrypt/Encryptable.java
package utils.encdecrypt;

import java.nio.file.Path;
import java.io.IOException;

public interface Encryptable {
    Path encryptFile(Path sourceFile, Path destDir) throws Exception;
    Path decryptFile(Path encryptedFile, Path destDir) throws Exception;
}

src/main/java/utils/encdecrypt/EncryptionAdapter.java
package utils.encdecrypt;

import java.nio.file.Path;
import java.util.Objects;



public final class EncryptionAdapter {
    private static volatile Encryptable handler;

    private EncryptionAdapter() {}

    public static void setHandler(Encryptable h) {
        handler = Objects.requireNonNull(h);
    }

    public static Path encrypt(Path compressedFile) throws Exception {
        if (handler == null) throw new IllegalStateException("Encryption handler not configured");
        return handler.encryptFile(compressedFile, compressedFile.getParent());
    }

    public static Path decrypt(Path encryptedFile) throws Exception {
        if (handler == null) throw new IllegalStateException("Encryption handler not configured");
        return handler.decryptFile(encryptedFile, encryptedFile.getParent());
    }
}

src/main/java/utils/SessionManager.java
package utils;

import java.io.*;

public final class SessionManager{ // make all the methods static bc i need to shure them all over the project and creating instatnce doesn make sense 
    private static String PATH = "session_storage.txt";

    public static void startSession(String username) throws IOException {
        try ( FileWriter fw = new FileWriter(PATH) ){
            fw.write(username + System.lineSeparator());

        }

    }

    public static boolean isLoggedIn(String username) throws IOException {
        String name ;
        try (BufferedReader br = new BufferedReader( new FileReader(PATH)) ) {  
            name = br.readLine();
        }

        if (name == null || !name.equals(username)) {
            return false;
        }

        return true; 
    }

    public static String who() throws FileNotFoundException, IOException {
        String name;
        try (BufferedReader br = new BufferedReader( new FileReader(PATH)) ) {
            name = br.readLine();

        }

        return name; 

    }

    public static void endSession() throws IOException {
        try ( FileWriter fw = new FileWriter(PATH) ) {
            fw.write("");// because append is false by default this will clear the line
        }
    }
}
src/main/java/utils/manifest/ManifestEntry.java
package utils.manifest;

import java.nio.file.Path;

public record ManifestEntry(
        Path original,
        String hash,
        long originalSize,
        String at

) {}

src/main/java/utils/manifest/ManifestDisplay.java
package utils.manifest;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.JsonNode;

import java.nio.file.Path;
import java.nio.file.Files;
import java.io.IOException;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;

public class ManifestDisplay {

    public static void display()  {
        try {
            Path manifestFile = Path.of("backup_workspace/temp/archive/manifest.json");
            if (!Files.exists(manifestFile)) {
                System.out.println("Manifest file not found!");
                return;
            }

            ObjectMapper mapper = new ObjectMapper();
            JsonNode root = mapper.readTree(manifestFile.toFile());
            JsonNode entries = root.get("entries");

            if (entries == null || !entries.isArray()) {
                System.out.println("No entries in manifest.");
                return;
            }

            System.out.printf("%-50s %-12s %-30s%n", "FILENAME", "SIZE", "TIMESTAMP");
            System.out.println("-------------------------------------------------------------------------------------");

            for (JsonNode entry : entries) {
                String original = entry.get("original").asText();
                long size = entry.get("originalSize").asLong();
                String time = entry.has("at") ? entry.get("at").asText() : "";

                System.out.printf(
                        "%-50s %-12s %-30s%n",
                        Path.of(original).getFileName().toString(),
                        humanReadableSize(size),
                        time
                        );
            }
        } catch (IOException ex){
            System.out.println("Error: " + ex);
        }

    }

    public static java.util.List<ManifestEntry> getEntries() {
        java.util.List<ManifestEntry> result = new java.util.ArrayList<>();

        try {
            Path manifestFile = Path.of("backup_workspace/temp/archive/manifest.json");
            if (!Files.exists(manifestFile)) {
                return result;
            }

            ObjectMapper mapper = new ObjectMapper();
            JsonNode root = mapper.readTree(manifestFile.toFile());
            JsonNode entriesNode = root.get("entries");

            if (entriesNode == null || !entriesNode.isArray()) {
                return result;
            }

            for (JsonNode node : entriesNode) {
                Path originalPath = Path.of(node.get("original").asText());
                String hash = node.get("hash").asText();
                long size = node.get("originalSize").asLong();
                String time = node.has("at") ? node.get("at").asText() : "";

                ManifestEntry entry = new ManifestEntry(
                        originalPath,
                        hash,
                        size,
                        time
                        );

                result.add(entry);
            }

        } catch (Exception ex) {
            // Status must never crash
            System.err.println("Manifest read failed: " + ex.getMessage());
        }

        return result;
    }

    private static String humanReadableSize(long bytes) {
        if (bytes < 1024) return bytes + " B";
        int exp = (int) (Math.log(bytes) / Math.log(1024));
        char pre = "KMGTPE".charAt(exp - 1);
        return String.format("%.1f %sB", bytes / Math.pow(1024, exp), pre);
    }
}

src/main/java/utils/manifest/ManifestBuilder.java
package utils.manifest;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.JsonNode;

import java.io.IOException;
import java.nio.file.*;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.List;
import java.net.URI;

import backup.BackupModel;

public class ManifestBuilder {

    private final List<ManifestEntry> entries = new ArrayList<>();
    private final Path manifestFile;
    private final BackupModel.Type backupType;
    private final ZonedDateTime timestamp;

    public ManifestBuilder(Path manifestDir, BackupModel.Type backupType) throws IOException {
        this.backupType = backupType;
        this.timestamp = ZonedDateTime.now();

        Files.createDirectories(manifestDir);
        this.manifestFile = manifestDir.resolve("manifest.json");

        loadExistingManifest();
    }

    private void loadExistingManifest() {
        if (!Files.exists(manifestFile)) return;

        try {
            ObjectMapper mapper = new ObjectMapper();
            JsonNode root = mapper.readTree(manifestFile.toFile());
            JsonNode arr = root.get("entries");

            if (arr != null && arr.isArray()) {
                for (JsonNode node : arr) {
                    String originalText = node.get("original").asText();
                    URI uri = URI.create(originalText);
                    Path originalPath = Paths.get(uri);

                    ManifestEntry entry = new ManifestEntry(
                            originalPath,
                            node.get("hash").asText(),
                            node.get("originalSize").asLong(),
                            node.get("at").asText()
                    );
                    entries.add(entry);
                }
            }
        } catch (Exception ex) {
            System.out.println("Failed to load existing manifest: " + ex.getMessage());
        }
    }

    public synchronized void addEntry(ManifestEntry entry) {
        entries.removeIf(e -> e.hash().equals(entry.hash()));
        entries.add(entry);
    }

    public synchronized void save() throws IOException {
        ObjectMapper mapper = new ObjectMapper();
        mapper.enable(SerializationFeature.INDENT_OUTPUT);

        var manifestObject = new ManifestRoot(
                backupType,
                timestamp.toString(),
                entries
        );

        mapper.writeValue(manifestFile.toFile(), manifestObject);
    }

    public synchronized List<ManifestEntry> getLoadedEntries() {
        return new ArrayList<>(entries); 
    }

    public record ManifestRoot(
            BackupModel.Type backupType,
            String timestamp,
            List<ManifestEntry> entries
    ) {}
}

src/main/java/main/Help.java
package main;

public class Help {
    public static void display(){
        System.out.println("""
                ============================================================
                                        BACKUP SYSTEM
                ============================================================

                Secure, modular command-line backup utility.

                Designed for reliable data protection using compression,
                encryption, and multiple storage backends.

                ------------------------------------------------------------
                USAGE
                ------------------------------------------------------------
                backup <command> [options]

                ------------------------------------------------------------
                COMMANDS
                ------------------------------------------------------------
                init
                Initialize the backup workspace and configuration files.

                backup
                Run a backup operation using the current configuration.

                restore
                Restore files from an existing backup archive.

                status
                Display information about existing backups and workspace
                health.

                config
                View or modify application configuration.

                help
                Show this help message.

                ------------------------------------------------------------
                BACKUP PIPELINE
                ------------------------------------------------------------
                1. File discovery
                2. Compression (gzip)
                3. Encryption (AES-based)
                4. Storage to target location
                5. Manifest generation and verification

                ------------------------------------------------------------
                SUPPORTED STORAGE TARGETS
                ------------------------------------------------------------
                 Local filesystem
                 External / mounted devices
                 SFTP remote servers

                ------------------------------------------------------------
                SECURITY FEATURES
                ------------------------------------------------------------
                 Encrypted backup archives
                 SHA-256 integrity verification
                 Password-based key derivation
                 Manifest-based recovery

        Welcome.display();
                ------------------------------------------------------------
                WORKSPACE LAYOUT
                ------------------------------------------------------------
                ./backup_workspace/
                 config.yaml
                 backups/
                 manifests/
                 temp/

                ------------------------------------------------------------
                EXAMPLES
                ------------------------------------------------------------
                Initialize workspace:
                backup init

                Run a backup:
                backup backup

                Restore files:
                backup restore

                Check status:
                backup status

                ------------------------------------------------------------
                ============================================================
                """
                );
    }
}
src/main/java/main/report/LogAnalyzer.java
package main.report;

import java.nio.file.*;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;
import java.util.stream.Collectors;

public class LogAnalyzer {
    
    private static final Path LOG_FILE = Path.of("backup_system.log");
    private static final DateTimeFormatter LOG_TIME_FORMATTER = 
        DateTimeFormatter.ofPattern("HH:mm:ss.SSSSSSSSS");
    
    public static LogReport generateReport() {
        LogReport report = new LogReport();
        
        try {
            List<String> lines = Files.readAllLines(LOG_FILE);
            
            for (String line : lines) {
                if (line == null || line.trim().isEmpty()) {
                    continue;
                }
                
                String[] parts = line.split("\\|");
                if (parts.length < 4) {
                    continue;
                }
                
                LogEntry entry = new LogEntry();
                entry.status = parts[0].trim();
                entry.source = parts[1].trim();
                entry.message = parts[2].trim();
                entry.timestamp = parts[3].trim();
                
                report.addEntry(entry);
            }
            
            report.analyze();
            
        } catch (IOException e) {
            System.err.println("Error reading log file: " + e.getMessage());
        }
        
        return report;
    }
    
    public static class LogEntry {
        String status;
        String source;
        String message;
        String timestamp;
       
        public String getStatus() { return status; }
        public String getSource() { return source; }
        public String getMessage() { return message; }
        public String getTimestamp() { return timestamp; }

        public boolean isSuccess() {
            return status.equalsIgnoreCase("SUCCESS");
        }
        
        public boolean isError() {
            return status.equalsIgnoreCase("ERROR");
        }
        
        public boolean isWarning() {
            return status.equalsIgnoreCase("WARNING");
        }
        
        public LocalDateTime getDateTime() {
            try {
                // Extract date from message if available
                if (message.contains("at ")) {
                    String dateStr = message.substring(message.indexOf("at ") + 3);
                    return LocalDateTime.parse(dateStr.replace("+03:00[Africa/Addis_Ababa]", ""));
                }
                return LocalDateTime.now(); // Fallback
            } catch (Exception e) {
                return LocalDateTime.now();
            }
        }
    }
    
    public static class LogReport {
        private List<LogEntry> entries = new ArrayList<>();
        private Map<String, Integer> statusCount = new HashMap<>();
        private Map<String, Integer> sourceCount = new HashMap<>();
        private Map<String, Integer> errorSources = new HashMap<>();
        private List<LogEntry> errors = new ArrayList<>();
        private List<LogEntry> successes = new ArrayList<>();
        private Map<String, Integer> messageFrequency = new HashMap<>();
        private LocalDateTime startTime;
        private LocalDateTime endTime;
        private int totalEntries = 0;
        private int successCount = 0;
        private int errorCount = 0;
        
        public void addEntry(LogEntry entry) {
            entries.add(entry);
            totalEntries++;
            
            // Update status count
            statusCount.merge(entry.status.toUpperCase(), 1, Integer::sum);
            
            // Update source count
            sourceCount.merge(entry.source.toLowerCase(), 1, Integer::sum);
            
            // Track errors
            if (entry.isError()) {
                errorCount++;
                errors.add(entry);
                errorSources.merge(entry.source, 1, Integer::sum);
            } else if (entry.isSuccess()) {
                successCount++;
                successes.add(entry);
            }
            
            // Track message frequency
            String keyMessage = entry.message.length() > 50 ? 
                entry.message.substring(0, 50) + "..." : entry.message;
            messageFrequency.merge(keyMessage, 1, Integer::sum);
            
            // Update time range
            LocalDateTime entryTime = entry.getDateTime();
            if (startTime == null || entryTime.isBefore(startTime)) {
                startTime = entryTime;
            }
            if (endTime == null || entryTime.isAfter(endTime)) {
                endTime = entryTime;
            }
        }
        
        public void analyze() {
            // Additional analysis can be done here
        }
        
        // Getters
        public List<LogEntry> getEntries() { return entries; }
        public Map<String, Integer> getStatusCount() { return statusCount; }
        public Map<String, Integer> getSourceCount() { return sourceCount; }
        public Map<String, Integer> getErrorSources() { return errorSources; }
        public List<LogEntry> getErrors() { return errors; }
        public List<LogEntry> getSuccesses() { return successes; }
        public Map<String, Integer> getMessageFrequency() { return messageFrequency; }
        public LocalDateTime getStartTime() { return startTime; }
        public LocalDateTime getEndTime() { return endTime; }
        public int getTotalEntries() { return totalEntries; }
        public int getSuccessCount() { return successCount; }
        public int getErrorCount() { return errorCount; }
        
        public double getSuccessRate() {
            return totalEntries > 0 ? (successCount * 100.0) / totalEntries : 0;
        }
        
        public String getMostActiveSource() {
            return sourceCount.entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse("N/A");
        }
        
        public String getMostCommonError() {
            return errorSources.entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse("N/A");
        }
    }
}
src/main/java/main/App.java
package main;

import java.io.IOException;
import java.io.FileNotFoundException;
import java.sql.SQLException;

import backup.*;
import recovery.*;
import utils.manifest.ManifestDisplay;
import utils.SessionManager;
import user.*;
import utils.Logger;
import exception.userservice.*;

public class App {
    public static void runCli(String[] args) {
        Welcome.display();

        if (args.length == 0) {
            Help.display();
            return;
        }

        String command = args[0];

        try {
            switch (command) {
                case "init" -> init();
                case "user" -> handleUser(args);
                case "backup" -> handleBackup(args);
                case "recover" -> handleRecovery(args);
                case "status" -> ManifestDisplay.display();
                case "help", "--help" -> Help.display();
                default -> {
                    System.out.println("Unknown command: " + command);
                    Help.display();
                }
            }
        } catch(UserNotFoundException e) {
            System.out.println(e.getMessage());
            Logger.log("ERROR","user-service", e.getMessage());
        } catch (SQLException e) {
            printSqlError(e);
        } catch (IOException e) {
            System.err.println("I/O error: " + e.getMessage());
            Logger.log("ERROR", "io", e.getMessage());
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            Logger.log("ERROR", "general", e.getMessage());
        } finally {
            try {
            if (SessionManager.who() != null) {
                SessionManager.endSession();
            }
            } catch (FileNotFoundException e){
                Logger.log("ERROR", "session", e.getMessage());
            } catch (IOException e){
                Logger.log("ERROR", "session", e.getMessage());
            }

        }

    }


    private static void init() throws SQLException {
         new UserService() ;
        System.out.println("SecureBackupSuite initialized.");
    }


    private static void handleUser(String[] args)
            throws SQLException, IOException, UserNotFoundException {

        if (args.length < 2) {
            System.out.println("Missing user command.");
            return;
        }

        UserService userService = new UserService();

        if ("update".equals(args[1])) {
            for (int i = 2; i < args.length; i++) {
                switch (args[i]) {
                    case "-c":
                        userService.createNewUser();
                        return;
                    case "-u":
                        userService.updateUsername(args[++i]);
                        break;
                    case "-p":
                        userService.updatePassword(args[++i]);
                        break;
                    case "-e":
                        userService.updateEmail(args[++i]);
                        break;
                    default:
                        throw new IllegalArgumentException(
                                "Invalid option: " + args[i]);
                }
            }
        } else {
            throw new IllegalArgumentException(
                    "Unknown user command: " + args[1]);
        }
    }


    private static void handleBackup(String[] args)
            throws Exception {

        if (args.length < 2) {
            System.out.println("Missing backup command.");
            return;
        }

        ensureLogin();

        Backupable service = null;

        switch (args[1]) {

            case "full":
                Backup.backup(
                        BackupModel.Type.FULL);
                service.backup();
                break;

            case "incremental":
                service = BackupServiceResolver.getService(
                        BackupModel.Type.INCREMENTAL);
                service.backup();
                break;

            case "stop":
                BackupDaemon.stop();
                System.out.println("Backup stopped.");
                break;

            default:
                throw new IllegalArgumentException(
                        "Invalid backup command: " + args[1]);
        }
    }


    private static void handleRecovery(String[] args)
            throws Exception {

        if (args.length < 2) {
            System.out.println("Missing recovery command.");
            return;
        }

        ensureLogin();

        Recoveryable service;

        switch (args[1]) {

            case "full":
                service = RecoveryServiceResolver.getService(
                        RecoveryModel.Type.FULL);
                service.recover();
                break;

            case "selective":
                service = RecoveryServiceResolver.getService(
                        RecoveryModel.Type.SELECTIVE);
                service.recover();
                break;

            default:
                throw new IllegalArgumentException(
                        "Invalid recovery command: " + args[1]);
        }
    }


    private static void ensureLogin()
            throws IOException , SQLException , UserNotFoundException ,InvalidCredentialsException {
        if (SessionManager.who() == null) {
            String username = user.UserUI.takeUsername();
            UserService userService = new UserService();

            userService.userLoggin(username);
            SessionManager.startSession(username);
        }
    }


    private static void printSqlError(SQLException e) {

        System.err.println("Database error occurred:");

        SQLException ex = e;
        while (ex != null) {
            System.err.println("Message   : " + ex.getMessage());
            System.err.println("SQLState  : " + ex.getSQLState());
            System.err.println("ErrorCode : " + ex.getErrorCode());
            System.err.println("----------------------------------");

            Logger.log(
                "SQL_ERROR",
                "database",
                "Message=" + ex.getMessage() +
                ", SQLState=" + ex.getSQLState() +
                ", Code=" + ex.getErrorCode()
            );

            ex = ex.getNextException();
        }
    }
}

src/main/java/main/Welcome.java
package main;


public class Welcome{
    public static void display() {
        System.out.println("""
                ============================================================
                                        BACKUP SYSTEM
                ============================================================

                Welcome.

                Backup System is a secure, modular command-line application
                designed to protect your data through reliable backups.

                It supports a full backup pipeline:
                 File discovery
                 Compression
                 Encryption
                 Storage to local or remote targets

                ------------------------------------------------------------
                SUPPORTED STORAGE
                ------------------------------------------------------------
                 Local filesystem
                 External / mounted devices
                 SMB network shares
                 SFTP remote servers

                ------------------------------------------------------------
                SECURITY
                ------------------------------------------------------------
                 Encrypted backup archives
                 SHA-256 file integrity verification
                 Manifest-based tracking and recovery

                ------------------------------------------------------------
                USAGE
                ------------------------------------------------------------
                backup <command> [options]

                COMMON COMMANDS
                ------------------------------------------------------------
                init        Initialize workspace and configuration
                backup      Run a backup operation
                restore     Restore files from backup
                status      Show backup status
                config      View or edit configuration
                help        Show help and command details

                ------------------------------------------------------------
                WORKSPACE
                ------------------------------------------------------------
                ./backup_workspace/

                ============================================================
                """);         

    }
}
src/main/java/main/gui/AppIcon.java
package main.gui;

import javafx.scene.image.Image;
import javafx.stage.Stage;

public class AppIcon {
    private static final Image ICON =
        new Image(AppIcon.class.getResource("/10109861.png").toExternalForm());

    public static void apply(Stage stage) {
        stage.getIcons().add(ICON);
    }
}

src/main/java/main/gui/Louncher.java
src/main/java/main/gui/HandleClose.java
package main.gui;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.stage.Stage;

public class HandleClose implements EventHandler<ActionEvent> {

    private final Stage stage;

    public HandleClose(Stage stage) {
        this.stage = stage;
    }

    @Override
    public void handle(ActionEvent event) {
        if (stage.isShowing()) {
            stage.close();
        }
    }
}

src/main/java/main/gui/Header.java
package main.gui;

import javafx.scene.control.Button;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.Scene;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import javafx.stage.Modality;
import javafx.scene.control.TableView;
import javafx.scene.control.SelectionMode;
import utils.manifest.*;

import backup.Backup;
import backup.BackupModel;
import recovery.Recovery;
import recovery.RecoveryModel;
import recovery.SelectiveRecoveryService;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class Header {

    public static HBox getHeader() {
        Button btnWelcome = new Button("Welcome");
        Button btnStatus = new Button("Status");
        Button btnLogs = new Button("Logs");
        Button btnHelp = new Button("Help");
        Button btnConfig = new Button("Configure");

        ComboBox<String> backupCombo = new ComboBox<>();
        ComboBox<String> recoveryCombo = new ComboBox<>();

        // Navigation buttons - use NavigationManager
        btnWelcome.setOnAction(e -> NavigationManager.navigateToWelcome());
        btnStatus.setOnAction(e -> NavigationManager.navigateToStatus());
        btnLogs.setOnAction(e -> NavigationManager.navigateToLogs());
        btnHelp.setOnAction(e -> NavigationManager.navigateToHelp());

        backupCombo.getItems().addAll("Full-Backup", "Incremental", "Predictive");
        recoveryCombo.getItems().addAll("Full-Recovery", "Selective-Recovery");

        backupCombo.setPromptText("Select Backup Type");
        recoveryCombo.setPromptText("Select Recovery Type");
       
        backupCombo.getStyleClass().add("prompt-styled");
        recoveryCombo.getStyleClass().add("prompt-styled");

        Stage backupPopup = new Stage();
        backupPopup.initModality(Modality.APPLICATION_MODAL);
        backupPopup.initOwner(NavigationManager.getPrimaryStage());
        backupPopup.setTitle("Confirm Backup");
        Button backupOk = new Button("Backup");
        Button backupCancel = new Button("Cancel");
        VBox backupRoot = new VBox(10, new Label("Do you want to make a backup?"),
                new HBox(20, backupOk, backupCancel));
        backupRoot.setPadding(new javafx.geometry.Insets(20));
        backupPopup.setScene(new Scene(backupRoot, 300, 150));
        backupCancel.setOnAction(e -> backupPopup.close());

        // Recovery Confirmation Popup
        Stage recoveryPopup = new Stage();
        recoveryPopup.initModality(Modality.APPLICATION_MODAL);
        recoveryPopup.initOwner(NavigationManager.getPrimaryStage());
        recoveryPopup.setTitle("Confirm Recovery");
        Button recoveryOk = new Button("Recover");
        Button recoveryCancel = new Button("Cancel");
        VBox recoveryRoot = new VBox(10, new Label("Do you want to make a recovery?"),
                new HBox(20, recoveryOk, recoveryCancel));
        recoveryRoot.setPadding(new javafx.geometry.Insets(20));
        recoveryPopup.setScene(new Scene(recoveryRoot, 300, 150));
        recoveryCancel.setOnAction(e -> recoveryPopup.close());

        // Selective Recovery Popup - CREATE FRESH INSTANCE EACH TIME
        // We'll create the dialog when needed, not at initialization
        Stage selectiveStage = null;
        TableView<ManifestEntry> selectiveTable = null;

        // Backup Combo Action
        backupCombo.setOnAction(e -> {
            String selected = backupCombo.getValue();
            if (selected != null) {
                backupPopup.show();
                backupOk.setOnAction(ok -> {
                    switch (selected) {
                        case "Full-Backup" -> Backup.backup(BackupModel.Type.FULL);
                        case "Incremental" -> Backup.backup(BackupModel.Type.INCREMENTAL);
                        case "Predictive" -> System.out.println("Predictive backup coming soon.");
                    }
                    backupPopup.close();
                    backupCombo.getSelectionModel().clearSelection();
                });
            }
        });

        // Recovery Combo Action
        recoveryCombo.setOnAction(e -> {
            String selected = recoveryCombo.getValue();
            if (selected != null) {
                if ("Selective-Recovery".equals(selected)) {
                    // Create fresh selective recovery dialog each time
                    showSelectiveRecoveryDialog();
                } else {
                    // Show confirmation for full recovery
                    recoveryPopup.show();
                    recoveryOk.setOnAction(ok -> {
                        if ("Full-Recovery".equals(selected)) {
                            Recovery.recover(RecoveryModel.Type.FULL);
                        }
                        recoveryPopup.close();
                        recoveryCombo.getSelectionModel().clearSelection();
                    });
                }
            }
        });

        // Configure Button Action
        btnConfig.setOnAction(e -> {
            try {
                File configFile = new File("config.yaml");
                if (!configFile.exists()) {
                    System.out.println("Config file not found.");
                    return;
                }

                String os = System.getProperty("os.name").toLowerCase();
                if (os.contains("win")) {
                    new ProcessBuilder("notepad.exe", configFile.getAbsolutePath()).start();
                } else if (os.contains("mac")) {
                    new ProcessBuilder("open", configFile.getAbsolutePath()).start();
                } else { 
                    new ProcessBuilder("xdg-open", configFile.getAbsolutePath()).start();
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        });

        // In Header.java, add report button
        Button btnReport = new Button("Report");
        btnReport.setOnAction(e -> NavigationManager.navigateToReport());


        HBox header = new HBox(10, 
                btnWelcome, btnStatus, btnReport, backupCombo, recoveryCombo, 
                btnLogs, btnHelp, btnConfig
                );

        header.getStyleClass().add("header");
        header.setPadding(new javafx.geometry.Insets(15));

        return header;
    }
    
    // Helper method to create selective recovery dialog
    private static void showSelectiveRecoveryDialog() {
        // Create fresh table instance for this dialog
        TableView<ManifestEntry> filesTable = StatusView.createSelectiveRecoveryTable();
        
        Stage selectiveStage = new Stage();
        selectiveStage.initModality(Modality.APPLICATION_MODAL);
        selectiveStage.initOwner(NavigationManager.getPrimaryStage());
        selectiveStage.setTitle("Selective Recovery");
        
        Button selectiveRecoverOk = new Button("Recover Selected");
        Button selectiveRecoverCancel = new Button("Cancel");
        
        selectiveRecoverCancel.setOnAction(e -> selectiveStage.close());
        
        VBox selectiveLayout = new VBox(10, 
            new Label("Select Files to Recover"),
            filesTable, 
            new HBox(20, selectiveRecoverOk, selectiveRecoverCancel)
        );
        selectiveLayout.setPadding(new javafx.geometry.Insets(20));
        
        selectiveRecoverOk.setOnAction(e -> {
            var selectedFiles = filesTable.getSelectionModel().getSelectedItems();
            if (!selectedFiles.isEmpty()) {
                Map<String, String> targetMap = new HashMap<>();
                for (ManifestEntry entry : selectedFiles) {
                    String[] fullPath = entry.original().toString().split("\\/");
                    String filename = fullPath[fullPath.length - 1];
                    targetMap.put(filename, entry.at());
                    System.out.println(entry.original().toString() + " " + entry.at());
                }
                SelectiveRecoveryService.setTarget(targetMap);
                try {
                    Recovery.recover(RecoveryModel.Type.SELECTIVE);
                } catch (Exception ex) {
                    ex.printStackTrace();
                }
                selectiveStage.close();
            }
        });
        
        Scene selectiveScene = new Scene(selectiveLayout, 900, 600);
        selectiveStage.setScene(selectiveScene);
        selectiveStage.show();
    }
}
src/main/java/main/gui/NavigationManager.java
package main.gui;

import javafx.scene.Scene;
import javafx.scene.layout.BorderPane;
import javafx.stage.Stage;

public class NavigationManager {
    private static Stage primaryStage;
    private static BorderPane rootLayout;
    
    public static void initialize(Stage stage) {
        primaryStage = stage;
        rootLayout = new BorderPane();
        
        rootLayout.setTop(Header.getHeader());
        
        Scene mainScene = new Scene(rootLayout, 1200, 700);
        mainScene.getStylesheets().add(
            NavigationManager.class.getResource("/styles/app.css").toExternalForm()
        );
        
        stage.setScene(mainScene);
        stage.setTitle("Backup System");
        AppIcon.apply(stage);
        stage.show();
        
        navigateToWelcome();
    }
    
    // Add report navigation
    public static void navigateToReport() {
        rootLayout.setCenter(main.gui.report.ReportView.getContent());
        primaryStage.setTitle("System Report - Backup System");
    }
    
    public static void navigateToWelcome() {
        rootLayout.setCenter(WelcomeView.getContent());
        primaryStage.setTitle("Welcome - Backup System");
    }
    
    public static void navigateToStatus() {
        rootLayout.setCenter(StatusView.getContent());
        primaryStage.setTitle("Status - Backup System");
    }
    
    public static void navigateToLogs() {
        rootLayout.setCenter(LogView.getContent());
        primaryStage.setTitle("Logs - Backup System");
    }
    
    public static void navigateToHelp() {
        rootLayout.setCenter(HelpView.getContent());
        primaryStage.setTitle("Help - Backup System");
    }
    
    public static Stage getPrimaryStage() {
        return primaryStage;
    }
    
    public static BorderPane getRootLayout() {
        return rootLayout;
    }
}
src/main/java/main/gui/StatusView.java
package main.gui;

import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.beans.property.SimpleStringProperty;
import utils.manifest.ManifestEntry;
import utils.manifest.ManifestDisplay;
import java.util.List;

public class StatusView {
    
    public static VBox getContent() {
        VBox content = new VBox(10);
        content.setPadding(new javafx.geometry.Insets(20));
        
        Label title = new Label("Backup Status");
        Label subtitle = new Label("View all backed up files and their details");
        
        TableView<ManifestEntry> table = createStatusTable();
        content.getChildren().addAll(title, subtitle, table);
        return content;
    }
    
    public static TableView<ManifestEntry> createStatusTable() {
        return createTableView();
    }
    
    public static TableView<ManifestEntry> createSelectiveRecoveryTable() {
        TableView<ManifestEntry> table = createTableView();
        table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
        return table;
    }
    
    private static TableView<ManifestEntry> createTableView() {
        List<ManifestEntry> manifestList = ManifestDisplay.getEntries();
        ObservableList<ManifestEntry> data = FXCollections.observableArrayList(manifestList);
        
        TableView<ManifestEntry> table = new TableView<>(data);
        
        // FIX: Disable the extra empty column
        table.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
        
        TableColumn<ManifestEntry, String> fileCol = new TableColumn<>("File Name");
        fileCol.setCellValueFactory(c -> new SimpleStringProperty(c.getValue().original().toString()));
        
        TableColumn<ManifestEntry, String> hashCol = new TableColumn<>("Hash");
        hashCol.setCellValueFactory(c -> new SimpleStringProperty(c.getValue().hash()));
        
        TableColumn<ManifestEntry, String> sizeCol = new TableColumn<>("Size");
        sizeCol.setCellValueFactory(c -> new SimpleStringProperty(
            String.valueOf(c.getValue().originalSize()) + " bytes"
        ));
        
        TableColumn<ManifestEntry, String> dateCol = new TableColumn<>("Date");
        dateCol.setCellValueFactory(c -> new SimpleStringProperty(c.getValue().at()));
        
        table.getColumns().addAll(fileCol, hashCol, sizeCol, dateCol);
        table.setPrefWidth(1000);
        table.setPrefHeight(500);
        
        return table;
    }
}
src/main/java/main/gui/LogView.java
package main.gui;

import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.beans.property.SimpleStringProperty;
import java.nio.file.*;
import java.io.IOException;
import java.util.List;

public class LogView {
    
    public static VBox getContent() {
        ObservableList<Log> logs = parseLogs();
        TableView<Log> table = createLogTable(logs);
        
        VBox content = new VBox(10);
        content.getStyleClass().add("card");
        content.setPadding(new javafx.geometry.Insets(20));
        
        Label title = new Label("System Logs");
        title.getStyleClass().add("title");
        
        Label subtitle = new Label("Complete log for backup and recovery operations");
        subtitle.getStyleClass().add("subtitle");
        
        content.getChildren().addAll(title, subtitle, table);
        return content;
    }
    
    private static TableView<Log> createLogTable(ObservableList<Log> logs) {
        TableView<Log> table = new TableView<>(logs);
        
        // FIX: Disable the extra empty column
        table.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
        
        TableColumn<Log, String> statusCol = new TableColumn<>("Status");
        statusCol.setCellValueFactory(data -> new SimpleStringProperty(data.getValue().getStatus()));
        statusCol.setPrefWidth(100);
        
        TableColumn<Log, String> sourceCol = new TableColumn<>("Source");
        sourceCol.setCellValueFactory(data -> new SimpleStringProperty(data.getValue().getSource()));
        sourceCol.setPrefWidth(150);
        
        TableColumn<Log, String> msgCol = new TableColumn<>("Message");
        msgCol.setCellValueFactory(data -> new SimpleStringProperty(data.getValue().getMsg()));
        msgCol.setPrefWidth(400);
        
        TableColumn<Log, String> dateCol = new TableColumn<>("Date");
        dateCol.setCellValueFactory(data -> new SimpleStringProperty(data.getValue().getDate()));
        dateCol.setPrefWidth(150);
        
        table.getColumns().addAll(statusCol, sourceCol, msgCol, dateCol);
        table.setPrefWidth(1100);
        table.setPrefHeight(500);
        
        return table;
    }
    
    private static ObservableList<Log> parseLogs() {
        ObservableList<Log> logs = FXCollections.observableArrayList();
        Path logFile = Path.of("backup_system.log");
        
        if (!Files.exists(logFile)) {
            Log noLogs = new Log();
            noLogs.setStatus("INFO");
            noLogs.setSource("System");
            noLogs.setMsg("No log file found");
            noLogs.setDate("-");
            logs.add(noLogs);
            return logs;
        }
        
        try {
            List<String> lines = Files.readAllLines(logFile);
            for (String line : lines) {
                if (line == null || line.isBlank()) continue;
                String[] tokens = line.split("\\|");
                if (tokens.length < 4) continue;
                
                Log log = new Log();
                log.setStatus(tokens[0].trim());
                log.setSource(tokens[1].trim());
                log.setMsg(tokens[2].trim());
                log.setDate(tokens[3].trim());
                logs.add(log);
            }
        } catch (IOException ex) {
            ex.printStackTrace();
        }
        
        return logs;
    }
}

class Log {
    private String status;
    private String source;
    private String msg;
    private String date;

    public String getStatus() { return status; }
    public String getSource() { return source; }
    public String getMsg() { return msg; }
    public String getDate() { return date; }

    public void setStatus(String status) { this.status = status; }
    public void setSource(String source) { this.source = source; }
    public void setMsg(String msg) { this.msg = msg; }
    public void setDate(String date) { this.date = date; }
}
src/main/java/main/gui/WelcomeView.java
package main.gui;

import javafx.scene.control.Label;
import javafx.scene.layout.*;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import main.report.LogAnalyzer;
import main.report.LogAnalyzer.LogReport;

public class WelcomeView {
    
    public static VBox getContent() {
        LogReport report = LogAnalyzer.generateReport();
        
        VBox mainContainer = new VBox(20);
        mainContainer.setPadding(new Insets(30));
        
        // Header
        Label title = new Label("Backup System Dashboard");
        title.setStyle("-fx-font-size: 24px; -fx-font-weight: bold;");
        
        // Stats Section
        HBox statsSection = createStatsSection(report);
        
        // Recent Activity
        VBox recentActivity = createRecentActivity(report);
        
        mainContainer.getChildren().addAll(title, statsSection, recentActivity);
        return mainContainer;
    }
    
    private static HBox createStatsSection(LogReport report) {
        HBox statsContainer = new HBox(15);
        statsContainer.setAlignment(Pos.CENTER);
        
        VBox totalOps = createStatCard("Total Operations", 
            String.valueOf(report.getTotalEntries()));
        VBox successCard = createStatCard("Success Rate", 
            String.format("%.1f%%", report.getSuccessRate()));
        VBox errorCard = createStatCard("Errors", 
            String.valueOf(report.getErrorCount()));
        VBox activeSource = createStatCard("Active Source", 
            report.getMostActiveSource());
        
        statsContainer.getChildren().addAll(totalOps, successCard, errorCard, activeSource);
        return statsContainer;
    }
    
    private static VBox createStatCard(String title, String value) {
        VBox card = new VBox(5);
        card.setPadding(new Insets(15));
        card.setStyle("-fx-background-color: white; -fx-background-radius: 8px; " +
                     "-fx-effect: dropshadow(gaussian, rgba(0,0,0,0.1), 5, 0, 0, 2);");
        card.setPrefWidth(150);
        card.setAlignment(Pos.CENTER);
        
        Label titleLabel = new Label(title);
        titleLabel.setStyle("-fx-font-size: 12px; -fx-text-fill: #7f8c8d;");
        
        Label valueLabel = new Label(value);
        valueLabel.setStyle("-fx-font-size: 20px; -fx-font-weight: bold; -fx-text-fill: #2c3e50;");
        
        card.getChildren().addAll(titleLabel, valueLabel);
        return card;
    }
    
    private static VBox createRecentActivity(LogReport report) {
        VBox container = new VBox(10);
        container.setPadding(new Insets(20));
        container.setStyle("-fx-background-color: white; -fx-background-radius: 8px; " +
                          "-fx-effect: dropshadow(gaussian, rgba(0,0,0,0.1), 5, 0, 0, 2);");
        
        Label sectionTitle = new Label("Recent Activity");
        sectionTitle.setStyle("-fx-font-size: 18px; -fx-font-weight: bold; -fx-text-fill: #2c3e50;");
        
        VBox activityList = new VBox(8);
        
        // Show last 5 entries
        int startIndex = Math.max(0, report.getEntries().size() - 5);
        for (int i = startIndex; i < report.getEntries().size(); i++) {
            var entry = report.getEntries().get(i);
            Label activity = new Label(String.format("[%s] %s - %s", 
                entry.getTimestamp(), entry.getSource(), entry.getMessage()));
            activity.setWrapText(true);
            activity.setStyle("-fx-font-size: 13px; -fx-text-fill: #5d6d7e;");
            activityList.getChildren().add(activity);
        }
        
        container.getChildren().addAll(sectionTitle, activityList);
        return container;
    }
}
src/main/java/main/gui/ReportView.java
package main.gui.report;

import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.geometry.Insets;
import javafx.scene.chart.*;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import main.report.LogAnalyzer;
import main.report.LogAnalyzer.LogReport;
import main.report.LogAnalyzer.LogEntry;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.paint.Color;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import javafx.scene.Scene;
import javafx.stage.Stage;
import javafx.geometry.Pos;

public class ReportView {
    
    public static ScrollPane getContent() {
        VBox mainContainer = new VBox(20);
        mainContainer.setPadding(new Insets(30));
        mainContainer.getStyleClass().add("report-container");
        
        // Generate report
        LogReport report = LogAnalyzer.generateReport();
        
        // Header
        HBox header = createHeader(report);
        
        // Stats Cards
        HBox statsSection = createStatsSection(report);
        
        // Charts Section
        HBox chartsSection = createChartsSection(report);
        
        // Error Analysis
        VBox errorSection = createErrorSection(report);
        
        // Source Analysis
        VBox sourceSection = createSourceSection(report);
        
        // Recent Activity
        VBox recentActivity = createRecentActivitySection(report);
        
        
        mainContainer.getChildren().addAll(
            header,
            statsSection,
            chartsSection,
            errorSection,
            sourceSection,
            recentActivity 
        );
        
        // Wrap in ScrollPane
        ScrollPane scrollPane = new ScrollPane(mainContainer);
        scrollPane.setFitToWidth(true);
        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
        
        return scrollPane;
    }
    
    private static HBox createHeader(LogReport report) {
        HBox header = new HBox(20);
        header.setAlignment(Pos.CENTER_LEFT);
        
        Label title = new Label("System Report & Analytics");
        title.setFont(Font.font("System", FontWeight.BOLD, 28));
        title.setTextFill(Color.web("#2c3e50"));
        
        Label subtitle = new Label("Generated from backup system logs");
        subtitle.setTextFill(Color.web("#7f8c8d"));
        subtitle.setFont(Font.font(14));
        
        VBox textBox = new VBox(5, title, subtitle);
        
        Label dateLabel = new Label(getDateRange(report));
        dateLabel.setTextFill(Color.web("#3498db"));
        dateLabel.setFont(Font.font("System", FontWeight.BOLD, 14));
        
        header.getChildren().addAll(textBox, dateLabel);
        HBox.setHgrow(textBox, Priority.ALWAYS);
        
        return header;
    }
    
    private static String getDateRange(LogReport report) {
        if (report.getStartTime() == null || report.getEndTime() == null) {
            return "Date range: N/A";
        }
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MMM dd, yyyy");
        return String.format("%s - %s", 
            report.getStartTime().format(formatter),
            report.getEndTime().format(formatter));
    }
    
    private static HBox createStatsSection(LogReport report) {
        HBox statsContainer = new HBox(15);
        statsContainer.setAlignment(Pos.CENTER);
        
        VBox totalOpsCard = createStatCard("Total Operations", 
            String.valueOf(report.getTotalEntries()), "#3498db");
        
        VBox successCard = createStatCard("Success Rate", 
            String.format("%.1f%%", report.getSuccessRate()), "#2ecc71");
        
        VBox errorCard = createStatCard("Errors", 
            String.valueOf(report.getErrorCount()), "#e74c3c");
        
        VBox activeSourceCard = createStatCard("Most Active Source", 
            report.getMostActiveSource(), "#9b59b6");
        
        statsContainer.getChildren().addAll(totalOpsCard, successCard, errorCard, activeSourceCard);
        return statsContainer;
    }
    
    private static VBox createStatCard(String title, String value, String color) {
        VBox card = new VBox(10);
        card.getStyleClass().add("stat-card");
        card.setPadding(new Insets(20));
        card.setPrefWidth(180);
        card.setAlignment(Pos.CENTER);
        
        Label titleLabel = new Label(title);
        titleLabel.getStyleClass().add("stat-title");
        titleLabel.setTextFill(Color.web("#7f8c8d"));
        
        Label valueLabel = new Label(value);
        valueLabel.getStyleClass().add("stat-value");
        valueLabel.setTextFill(Color.web(color));
        valueLabel.setFont(Font.font("System", FontWeight.BOLD, 22));
        
        card.getChildren().addAll(titleLabel, valueLabel);
        return card;
    }
    
    private static HBox createChartsSection(LogReport report) {
        HBox chartsContainer = new HBox(20);
        chartsContainer.setAlignment(Pos.CENTER);
        
        // Pie Chart for Status Distribution
        VBox pieChartBox = new VBox(10);
        pieChartBox.setPadding(new Insets(20));
        pieChartBox.getStyleClass().add("chart-card");
        
        Label pieTitle = new Label("Status Distribution");
        pieTitle.getStyleClass().add("chart-title");
        
        PieChart statusChart = createStatusPieChart(report);
        statusChart.setPrefSize(300, 250);
        
        pieChartBox.getChildren().addAll(pieTitle, statusChart);
        
        // Bar Chart for Source Activity
        VBox barChartBox = new VBox(10);
        barChartBox.setPadding(new Insets(20));
        barChartBox.getStyleClass().add("chart-card");
        
        Label barTitle = new Label("Source Activity");
        barTitle.getStyleClass().add("chart-title");
        
        BarChart<String, Number> sourceChart = createSourceBarChart(report);
        sourceChart.setPrefSize(400, 250);
        
        barChartBox.getChildren().addAll(barTitle, sourceChart);
        
        chartsContainer.getChildren().addAll(pieChartBox, barChartBox);
        return chartsContainer;
    }
    
    private static PieChart createStatusPieChart(LogReport report) {
        ObservableList<PieChart.Data> pieChartData = FXCollections.observableArrayList();
        
        for (Map.Entry<String, Integer> entry : report.getStatusCount().entrySet()) {
            String status = entry.getKey();
            int count = entry.getValue();
            
            PieChart.Data data = new PieChart.Data(status + " (" + count + ")", count);
            pieChartData.add(data);
        }
        
        PieChart chart = new PieChart(pieChartData);
        chart.setLabelsVisible(true);
        chart.setLegendVisible(false);
        
        return chart;
    }
    
    private static BarChart<String, Number> createSourceBarChart(LogReport report) {
        CategoryAxis xAxis = new CategoryAxis();
        NumberAxis yAxis = new NumberAxis();
        BarChart<String, Number> barChart = new BarChart<>(xAxis, yAxis);
        
        XYChart.Series<String, Number> series = new XYChart.Series<>();
        series.setName("Operations by Source");
        
        // Get top 5 sources
        report.getSourceCount().entrySet().stream()
            .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
            .limit(5)
            .forEach(entry -> 
                series.getData().add(new XYChart.Data<>(entry.getKey(), entry.getValue()))
            );
        
        barChart.getData().add(series);
        barChart.setLegendVisible(false);
        barChart.setAnimated(false);
        
        return barChart;
    }
    
    private static VBox createErrorSection(LogReport report) {
        VBox errorContainer = new VBox(15);
        errorContainer.setPadding(new Insets(25));
        errorContainer.getStyleClass().add("section-card");
        
        Label title = new Label("Error Analysis");
        title.getStyleClass().add("section-title");
        title.setFont(Font.font("System", FontWeight.BOLD, 20));
        
        if (report.getErrors().isEmpty()) {
            Label noErrors = new Label("No errors found in the logs.");
            noErrors.setTextFill(Color.web("#7f8c8d"));
            errorContainer.getChildren().addAll(title, noErrors);
            return errorContainer;
        }
        
        // Error Summary
        HBox summaryBox = new HBox(20);
        summaryBox.setAlignment(Pos.CENTER_LEFT);
        
        Label errorCountLabel = new Label("Total Errors: " + report.getErrorCount());
        errorCountLabel.setTextFill(Color.web("#e74c3c"));
        
        Label commonErrorLabel = new Label("Most Common: " + report.getMostCommonError());
        commonErrorLabel.setTextFill(Color.web("#7f8c8d"));
        
        summaryBox.getChildren().addAll(errorCountLabel, commonErrorLabel);
        
        // Error List
        VBox errorList = new VBox(10);
        
        report.getErrors().stream()
            .limit(5)
            .forEach(error -> {
                HBox errorItem = new HBox(10);
                errorItem.setPadding(new Insets(10));
                errorItem.getStyleClass().add("error-item");
                
                Label sourceLabel = new Label(error.getSource());
                sourceLabel.setStyle("-fx-font-weight: bold; -fx-text-fill: #e74c3c;");
                
                Label messageLabel = new Label(error.getMessage());
                messageLabel.setTextFill(Color.web("#5d6d7e"));
                messageLabel.setWrapText(true);
                
                Label timeLabel = new Label(error.getTimestamp());
                timeLabel.setTextFill(Color.web("#95a5a6"));
                timeLabel.setFont(Font.font(12));
                
                errorItem.getChildren().addAll(sourceLabel, messageLabel, timeLabel);
                HBox.setHgrow(messageLabel, Priority.ALWAYS);
                
                errorList.getChildren().add(errorItem);
            });
        
        Button viewAllErrors = new Button("View All Errors");
        viewAllErrors.getStyleClass().add("view-all-btn");
        viewAllErrors.setOnAction(e -> showAllErrors(report));
        
        errorContainer.getChildren().addAll(title, summaryBox, errorList, viewAllErrors);
        return errorContainer;
    }
    
    private static VBox createSourceSection(LogReport report) {
        VBox sourceContainer = new VBox(15);
        sourceContainer.setPadding(new Insets(25));
        sourceContainer.getStyleClass().add("section-card");
        
        Label title = new Label("Source Breakdown");
        title.getStyleClass().add("section-title");
        title.setFont(Font.font("System", FontWeight.BOLD, 20));
        
        TableView<SourceStat> sourceTable = new TableView<>();
        
        TableColumn<SourceStat, String> sourceCol = new TableColumn<>("Source");
        sourceCol.setCellValueFactory(data -> new javafx.beans.property.SimpleStringProperty(data.getValue().source));
        sourceCol.setPrefWidth(150);
        
        TableColumn<SourceStat, Integer> countCol = new TableColumn<>("Operations");
        countCol.setCellValueFactory(data -> new javafx.beans.property.SimpleIntegerProperty(data.getValue().count).asObject());
        countCol.setPrefWidth(100);
        
        TableColumn<SourceStat, String> percentageCol = new TableColumn<>("Percentage");
        percentageCol.setCellValueFactory(data -> new javafx.beans.property.SimpleStringProperty(
            String.format("%.1f%%", (data.getValue().count * 100.0) / report.getTotalEntries())
        ));
        percentageCol.setPrefWidth(100);
        
        sourceTable.getColumns().addAll(sourceCol, countCol, percentageCol);
        
        ObservableList<SourceStat> sourceData = FXCollections.observableArrayList();
        report.getSourceCount().entrySet().stream()
            .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
            .forEach(entry -> sourceData.add(new SourceStat(entry.getKey(), entry.getValue())));
        
        sourceTable.setItems(sourceData);
        sourceTable.setPrefHeight(200);
        
        sourceContainer.getChildren().addAll(title, sourceTable);
        return sourceContainer;
    }
    
    private static class SourceStat {
        String source;
        int count;
        
        SourceStat(String source, int count) {
            this.source = source;
            this.count = count;
        }
    }
    
    private static VBox createRecentActivitySection(LogReport report) {
        VBox activityContainer = new VBox(15);
        activityContainer.setPadding(new Insets(25));
        activityContainer.getStyleClass().add("section-card");
        
        Label title = new Label("Recent Activity");
        title.getStyleClass().add("section-title");
        title.setFont(Font.font("System", FontWeight.BOLD, 20));
        
        VBox activityList = new VBox(10);
        
        // Show last 10 entries
        report.getEntries().stream()
            .skip(Math.max(0, report.getEntries().size() - 10))
            .forEach(entry -> {
                HBox activityItem = new HBox(10);
                activityItem.setPadding(new Insets(8));
                activityItem.getStyleClass().add("activity-item");
                
                VBox details = new VBox(3);
                
                HBox header = new HBox(10);
                header.setAlignment(Pos.CENTER_LEFT);
                
                Label sourceLabel = new Label(entry.getSource());
                sourceLabel.setStyle("-fx-font-weight: bold;");
                
                Label timeLabel = new Label(entry.getTimestamp());
                timeLabel.setTextFill(Color.web("#7f8c8d"));
                timeLabel.setFont(Font.font(12));
                
                header.getChildren().addAll(sourceLabel, timeLabel);
                
                Label messageLabel = new Label(entry.getMessage());
                messageLabel.setTextFill(Color.web("#5d6d7e"));
                messageLabel.setWrapText(true);
                
                details.getChildren().addAll(header, messageLabel);
                HBox.setHgrow(details, Priority.ALWAYS);
                
                activityItem.getChildren().addAll(details);
                activityList.getChildren().add(activityItem);
            });
        
        activityContainer.getChildren().addAll(title, activityList);
        return activityContainer;
    }
    
    
    private static void showAllErrors(LogReport report) {
        Stage errorStage = new Stage();
        errorStage.setTitle("All System Errors");
        
        VBox container = new VBox(20);
        container.setPadding(new Insets(30));
        
        Label title = new Label("All Error Logs (" + report.getErrorCount() + " errors)");
        title.setFont(Font.font("System", FontWeight.BOLD, 24));
        
        TableView<ErrorDetail> errorTable = new TableView<>();
        
        TableColumn<ErrorDetail, String> sourceCol = new TableColumn<>("Source");
        sourceCol.setCellValueFactory(data -> new javafx.beans.property.SimpleStringProperty(data.getValue().source));
        sourceCol.setPrefWidth(150);
        
        TableColumn<ErrorDetail, String> messageCol = new TableColumn<>("Error Message");
        messageCol.setCellValueFactory(data -> new javafx.beans.property.SimpleStringProperty(data.getValue().message));
        messageCol.setPrefWidth(400);
        
        TableColumn<ErrorDetail, String> timeCol = new TableColumn<>("Timestamp");
        timeCol.setCellValueFactory(data -> new javafx.beans.property.SimpleStringProperty(data.getValue().timestamp));
        timeCol.setPrefWidth(150);
        
        errorTable.getColumns().addAll(sourceCol, messageCol, timeCol);
        
        ObservableList<ErrorDetail> errorData = FXCollections.observableArrayList();
        report.getErrors().forEach(error -> 
            errorData.add(new ErrorDetail(error.getSource(), error.getMessage(), error.getTimestamp()))
        );
        
        errorTable.setItems(errorData);
        
        container.getChildren().addAll(title, errorTable);
        Scene scene = new Scene(new ScrollPane(container), 800, 600);
        errorStage.setScene(scene);
        errorStage.show();
    }
    
    private static class ErrorDetail {
        String source;
        String message;
        String timestamp;
        
        ErrorDetail(String source, String message, String timestamp) {
            this.source = source;
            this.message = message;
            this.timestamp = timestamp;
        }
    }
    
}
src/main/java/main/gui/HelpView.java
package main.gui;

import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.geometry.Insets;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;

public class HelpView {
    
    public static ScrollPane getContent() {
        VBox content = new VBox(20);
        content.setPadding(new Insets(30));
        content.setStyle("-fx-background-color: #f8f9fa;");
        
        // Header
        Label title = new Label("Backup System Help");
        title.setFont(Font.font("System", FontWeight.BOLD, 28));
        title.setTextFill(Color.web("#2c3e50"));
        
        Label subtitle = new Label("Documentation and usage guide");
        subtitle.setTextFill(Color.web("#7f8c8d"));
        subtitle.setFont(Font.font(14));
        
        VBox headerBox = new VBox(5, title, subtitle);
        
        // Content Sections
        VBox sections = new VBox(25);
        
        sections.getChildren().addAll(
            createSection("Usage", "backup <command> [options]"),
            createSection("Commands", 
                " init: Initialize workspace and configuration\n" +
                " backup: Run backup operation\n" +
                " restore: Restore files from backup\n" +
                " status: Display backup status\n" +
                " config: View or modify configuration\n" +
                " help: Show this help page"),
            createSection("Backup Pipeline",
                "1. File discovery\n" +
                "2. Compression (gzip)\n" +
                "3. Encryption (AES-based)\n" +
                "4. Storage to target location\n" +
                "5. Manifest generation and verification"),
            createSection("Storage Targets",
                " Local filesystem\n" +
                " External devices\n" +
                " SFTP servers"),
            createSection("Security Features",
                " Encrypted backup archives\n" +
                " SHA-256 integrity verification\n" +
                " Password-based key derivation\n" +
                " Manifest-based recovery"),
            createSection("Examples",
                "Initialize workspace:\n  backup init\n\n" +
                "Run a backup:\n  backup backup\n\n" +
                "Restore files:\n  backup restore\n\n" +
                "Check status:\n  backup status")
        );
        
        content.getChildren().addAll(headerBox, sections);
        
        ScrollPane scrollPane = new ScrollPane(content);
        scrollPane.setFitToWidth(true);
        scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        
        return scrollPane;
    }
    
    private static VBox createSection(String title, String content) {
        VBox section = new VBox(10);
        section.setPadding(new Insets(20));
        section.setStyle("-fx-background-color: white; -fx-background-radius: 8px; " +
                        "-fx-effect: dropshadow(gaussian, rgba(0,0,0,0.1), 8, 0, 0, 2);");
        
        Label titleLabel = new Label(title);
        titleLabel.setFont(Font.font("System", FontWeight.BOLD, 18));
        titleLabel.setTextFill(Color.web("#3498db"));
        
        Label contentLabel = new Label(content);
        contentLabel.setTextFill(Color.web("#5d6d7e"));
        contentLabel.setWrapText(true);
        contentLabel.setLineSpacing(1.5);
        
        section.getChildren().addAll(titleLabel, contentLabel);
        return section;
    }
}
src/main/java/main/TestFx.java
package main;

import javafx.application.Application;
import javafx.stage.Stage;
import main.gui.NavigationManager;

public class TestFx extends Application {

    @Override
    public void start(Stage stage) {
        NavigationManager.initialize(stage);
    }

    public static void launchFx(String[] args) {
        Application.launch(TestFx.class, args);
    }
}

src/main/java/main/Launcher.java
package main;

public class Launcher {

    public static void main(String[] args) {
        if (args.length == 0 || args[0].equalsIgnoreCase("gui")) {
            TestFx.launchFx(args);
        } else {
            App.runCli(args);
        }
    }
}

src/main/java/exception/userservice/UsernameExistsException.java
package exception.userservice;

public class UsernameExistsException extends Exception {
    public UsernameExistsException() {
        super("username found. Use another username or try Login.");
    }
}
src/main/java/exception/userservice/InvalidUsernameException.java
package exception.userservice;

public class InvalidUsernameException extends Exception {
    public InvalidUsernameException(){
        super("Invalid username can't be to short or to long.");
    }
}
src/main/java/exception/userservice/InvalidPasswordException.java
package exception.userservice;

public class InvalidPasswordException extends Exception {
    public InvalidPasswordException() {
        super("Password must be 8 charchter or longer.");
    }
}
src/main/java/exception/userservice/EmailExistsException.java
package exception.userservice;

public class EmailExistsException extends Exception {
    public EmailExistsException() { // bc in java when exception is to be printed it uses the getMessage() here we we pass message to it
        super("Subscription found. Use another email or try Login.");
    }
}
src/main/java/exception/userservice/InvalidEmailFormatException.java
package exception.userservice;

public class InvalidEmailFormatException extends Exception {
    public InvalidEmailFormatException() {
        super("Invalid Email format.");
    }
}
src/main/java/exception/userservice/UserNotFoundException.java
package exception.userservice;

public class UserNotFoundException extends Exception {
    public UserNotFoundException(){
        super("No associated acount found with the given username.");
    }
}
src/main/java/exception/userservice/InvalidCredentialsException.java
package exception.userservice;

public class InvalidCredentialsException extends Exception {
    public InvalidCredentialsException() {
        super("Invalid username or passoword.");
    }
}
src/main/java/exception/connecion/ShareNotFoundException.java
package exception.connection;

public class ShareNotFoundException extends ConnectionTestException {
    public ShareNotFoundException(String msg, Exception cause){
        super(msg, cause);

    }
}
src/main/java/exception/connecion/HostUnreachableException.java
package exception.connection;

public class HostUnreachableException extends ConnectionTestException {
    public HostUnreachableException(String host){
        super("unable to reach host: " + host);

    }

    public HostUnreachableException(String host,Exception cause){
        super("unable to reach host: " + host, cause);

    }
}
src/main/java/exception/connecion/ConnectionTestException.java
package exception.connection;

public class ConnectionTestException extends Exception {
    public ConnectionTestException(String msg, Exception cause) {
        super(msg, cause);
    }

    public ConnectionTestException(String msg) {
        super(msg);
    }
}
src/main/java/exception/connecion/AuthFailedException.java
package exception.connection;

public class AuthFailedException extends ConnectionTestException {
    public AuthFailedException(String msg){
        super(msg);

    }

    public AuthFailedException(String msg, Exception cause){
        super(msg, cause);

    }
}
